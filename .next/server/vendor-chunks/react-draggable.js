"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-draggable";
exports.ids = ["vendor-chunks/react-draggable"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/Draggable.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/Draggable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"DraggableCore\", ({\n    enumerable: true,\n    get: function() {\n        return _DraggableCore.default;\n    }\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js\"));\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _DraggableCore = _interopRequireDefault(__webpack_require__(/*! ./DraggableCore */ \"(ssr)/./node_modules/react-draggable/build/cjs/DraggableCore.js\"));\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n} /*:: import type {ControlPosition, PositionOffsetControlPosition, DraggableCoreProps, DraggableCoreDefaultProps} from './DraggableCore';*/ \n/*:: import type {Bounds, DraggableEventHandler} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ /*:: type DraggableState = {\n  dragging: boolean,\n  dragged: boolean,\n  x: number, y: number,\n  slackX: number, slackY: number,\n  isElementSVG: boolean,\n  prevPropsPosition: ?ControlPosition,\n};*/ /*:: export type DraggableDefaultProps = {\n  ...DraggableCoreDefaultProps,\n  axis: 'both' | 'x' | 'y' | 'none',\n  bounds: Bounds | string | false,\n  defaultClassName: string,\n  defaultClassNameDragging: string,\n  defaultClassNameDragged: string,\n  defaultPosition: ControlPosition,\n  scale: number,\n};*/ /*:: export type DraggableProps = {\n  ...DraggableCoreProps,\n  ...DraggableDefaultProps,\n  positionOffset: PositionOffsetControlPosition,\n  position: ControlPosition,\n};*/ //\n// Define <Draggable>\n//\nclass Draggable extends React.Component /*:: <DraggableProps, DraggableState>*/  {\n    // React 16.3+\n    // Arity (props, state)\n    static getDerivedStateFromProps(_ref /*:: */ , _ref2 /*:: */ ) /*: ?Partial<DraggableState>*/ {\n        let { position } /*: DraggableProps*/  = _ref /*: DraggableProps*/ ;\n        let { prevPropsPosition } /*: DraggableState*/  = _ref2 /*: DraggableState*/ ;\n        // Set x/y if a new position is provided in props that is different than the previous.\n        if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {\n            (0, _log.default)(\"Draggable: getDerivedStateFromProps %j\", {\n                position,\n                prevPropsPosition\n            });\n            return {\n                x: position.x,\n                y: position.y,\n                prevPropsPosition: {\n                    ...position\n                }\n            };\n        }\n        return null;\n    }\n    constructor(props /*: DraggableProps*/ ){\n        super(props);\n        _defineProperty(this, \"onDragStart\", (e, coreData)=>{\n            (0, _log.default)(\"Draggable: onDragStart: %j\", coreData);\n            // Short-circuit if user's callback killed it.\n            const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));\n            // Kills start event on core as well, so move handlers are never bound.\n            if (shouldStart === false) return false;\n            this.setState({\n                dragging: true,\n                dragged: true\n            });\n        });\n        _defineProperty(this, \"onDrag\", (e, coreData)=>{\n            if (!this.state.dragging) return false;\n            (0, _log.default)(\"Draggable: onDrag: %j\", coreData);\n            const uiData = (0, _positionFns.createDraggableData)(this, coreData);\n            const newState = {\n                x: uiData.x,\n                y: uiData.y,\n                slackX: 0,\n                slackY: 0\n            };\n            // Keep within bounds.\n            if (this.props.bounds) {\n                // Save original x and y.\n                const { x, y } = newState;\n                // Add slack to the values used to calculate bound position. This will ensure that if\n                // we start removing slack, the element won't react to it right away until it's been\n                // completely removed.\n                newState.x += this.state.slackX;\n                newState.y += this.state.slackY;\n                // Get bound position. This will ceil/floor the x and y within the boundaries.\n                const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);\n                newState.x = newStateX;\n                newState.y = newStateY;\n                // Recalculate slack by noting how much was shaved by the boundPosition handler.\n                newState.slackX = this.state.slackX + (x - newState.x);\n                newState.slackY = this.state.slackY + (y - newState.y);\n                // Update the event we fire to reflect what really happened after bounds took effect.\n                uiData.x = newState.x;\n                uiData.y = newState.y;\n                uiData.deltaX = newState.x - this.state.x;\n                uiData.deltaY = newState.y - this.state.y;\n            }\n            // Short-circuit if user's callback killed it.\n            const shouldUpdate = this.props.onDrag(e, uiData);\n            if (shouldUpdate === false) return false;\n            this.setState(newState);\n        });\n        _defineProperty(this, \"onDragStop\", (e, coreData)=>{\n            if (!this.state.dragging) return false;\n            // Short-circuit if user's callback killed it.\n            const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));\n            if (shouldContinue === false) return false;\n            (0, _log.default)(\"Draggable: onDragStop: %j\", coreData);\n            const newState /*: Partial<DraggableState>*/  = {\n                dragging: false,\n                slackX: 0,\n                slackY: 0\n            };\n            // If this is a controlled component, the result of this operation will be to\n            // revert back to the old position. We expect a handler on `onDragStop`, at the least.\n            const controlled = Boolean(this.props.position);\n            if (controlled) {\n                const { x, y } = this.props.position;\n                newState.x = x;\n                newState.y = y;\n            }\n            this.setState(newState);\n        });\n        this.state = {\n            // Whether or not we are currently dragging.\n            dragging: false,\n            // Whether or not we have been dragged before.\n            dragged: false,\n            // Current transform x and y.\n            x: props.position ? props.position.x : props.defaultPosition.x,\n            y: props.position ? props.position.y : props.defaultPosition.y,\n            prevPropsPosition: {\n                ...props.position\n            },\n            // Used for compensating for out-of-bounds drags\n            slackX: 0,\n            slackY: 0,\n            // Can only determine if SVG after mounting\n            isElementSVG: false\n        };\n        if (props.position && !(props.onDrag || props.onStop)) {\n            // eslint-disable-next-line no-console\n            console.warn(\"A `position` was applied to this <Draggable>, without drag handlers. This will make this \" + \"component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the \" + \"`position` of this element.\");\n        }\n    }\n    componentDidMount() {\n        // Check to see if the element passed is an instanceof SVGElement\n        if (typeof window.SVGElement !== \"undefined\" && this.findDOMNode() instanceof window.SVGElement) {\n            this.setState({\n                isElementSVG: true\n            });\n        }\n    }\n    componentWillUnmount() {\n        this.setState({\n            dragging: false\n        }); // prevents invariant if unmounted while dragging\n    }\n    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n    // the underlying DOM node ourselves. See the README for more information.\n    findDOMNode() /*: ?HTMLElement*/ {\n        var _this$props$nodeRef$c, _this$props;\n        return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 || (_this$props = _this$props.nodeRef) === null || _this$props === void 0 ? void 0 : _this$props.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);\n    }\n    render() /*: ReactElement<any>*/ {\n        const { axis, bounds, children, defaultPosition, defaultClassName, defaultClassNameDragging, defaultClassNameDragged, position, positionOffset, scale, ...draggableCoreProps } = this.props;\n        let style = {};\n        let svgTransform = null;\n        // If this is controlled, we don't want to move it - unless it's dragging.\n        const controlled = Boolean(position);\n        const draggable = !controlled || this.state.dragging;\n        const validPosition = position || defaultPosition;\n        const transformOpts = {\n            // Set left if horizontal drag is enabled\n            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,\n            // Set top if vertical drag is enabled\n            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y\n        };\n        // If this element was SVG, we use the `transform` attribute.\n        if (this.state.isElementSVG) {\n            svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);\n        } else {\n            // Add a CSS transform to move the element around. This allows us to move the element around\n            // without worrying about whether or not it is relatively or absolutely positioned.\n            // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>\n            // has a clean slate.\n            style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);\n        }\n        // Mark with class while dragging\n        const className = (0, _clsx.default)(children.props.className || \"\", defaultClassName, {\n            [defaultClassNameDragging]: this.state.dragging,\n            [defaultClassNameDragged]: this.state.dragged\n        });\n        // Reuse the child provided\n        // This makes it flexible to use whatever element is wanted (div, ul, etc)\n        return /*#__PURE__*/ React.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {\n            onStart: this.onDragStart,\n            onDrag: this.onDrag,\n            onStop: this.onDragStop\n        }), /*#__PURE__*/ React.cloneElement(React.Children.only(children), {\n            className: className,\n            style: {\n                ...children.props.style,\n                ...style\n            },\n            transform: svgTransform\n        }));\n    }\n}\nexports[\"default\"] = Draggable;\n_defineProperty(Draggable, \"displayName\", \"Draggable\");\n_defineProperty(Draggable, \"propTypes\", {\n    // Accepts all props <DraggableCore> accepts.\n    ..._DraggableCore.default.propTypes,\n    /**\n   * `axis` determines which axis the draggable can move.\n   *\n   *  Note that all callbacks will still return data as normal. This only\n   *  controls flushing to the DOM.\n   *\n   * 'both' allows movement horizontally and vertically.\n   * 'x' limits movement to horizontal axis.\n   * 'y' limits movement to vertical axis.\n   * 'none' limits all movement.\n   *\n   * Defaults to 'both'.\n   */ axis: _propTypes.default.oneOf([\n        \"both\",\n        \"x\",\n        \"y\",\n        \"none\"\n    ]),\n    /**\n   * `bounds` determines the range of movement available to the element.\n   * Available values are:\n   *\n   * 'parent' restricts movement within the Draggable's parent node.\n   *\n   * Alternatively, pass an object with the following properties, all of which are optional:\n   *\n   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}\n   *\n   * All values are in px.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable bounds={{right: 300, bottom: 300}}>\n   *              <div>Content</div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */ bounds: _propTypes.default.oneOfType([\n        _propTypes.default.shape({\n            left: _propTypes.default.number,\n            right: _propTypes.default.number,\n            top: _propTypes.default.number,\n            bottom: _propTypes.default.number\n        }),\n        _propTypes.default.string,\n        _propTypes.default.oneOf([\n            false\n        ])\n    ]),\n    defaultClassName: _propTypes.default.string,\n    defaultClassNameDragging: _propTypes.default.string,\n    defaultClassNameDragged: _propTypes.default.string,\n    /**\n   * `defaultPosition` specifies the x and y that the dragged item should start at\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable defaultPosition={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */ defaultPosition: _propTypes.default.shape({\n        x: _propTypes.default.number,\n        y: _propTypes.default.number\n    }),\n    positionOffset: _propTypes.default.shape({\n        x: _propTypes.default.oneOfType([\n            _propTypes.default.number,\n            _propTypes.default.string\n        ]),\n        y: _propTypes.default.oneOfType([\n            _propTypes.default.number,\n            _propTypes.default.string\n        ])\n    }),\n    /**\n   * `position`, if present, defines the current position of the element.\n   *\n   *  This is similar to how form elements in React work - if no `position` is supplied, the component\n   *  is uncontrolled.\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable position={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */ position: _propTypes.default.shape({\n        x: _propTypes.default.number,\n        y: _propTypes.default.number\n    }),\n    /**\n   * These properties should be defined on the child, not here.\n   */ className: _shims.dontSetMe,\n    style: _shims.dontSetMe,\n    transform: _shims.dontSetMe\n});\n_defineProperty(Draggable, \"defaultProps\", {\n    ..._DraggableCore.default.defaultProps,\n    axis: \"both\",\n    bounds: false,\n    defaultClassName: \"react-draggable\",\n    defaultClassNameDragging: \"react-draggable-dragging\",\n    defaultClassNameDragged: \"react-draggable-dragged\",\n    defaultPosition: {\n        x: 0,\n        y: 0\n    },\n    scale: 1\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZILGlEQUFnRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0gsT0FBT0MsZUFBZUMsT0FBTztJQUMvQjtBQUNGLENBQUMsRUFBQztBQUNGTCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSU0sUUFBUUMsd0JBQXdCQyxtQkFBT0EsQ0FBQyx3R0FBTztBQUNuRCxJQUFJQyxhQUFhQyx1QkFBdUJGLG1CQUFPQSxDQUFDLDREQUFZO0FBQzVELElBQUlHLFlBQVlELHVCQUF1QkYsbUJBQU9BLENBQUMsZ0hBQVc7QUFDMUQsSUFBSUksUUFBUUYsdUJBQXVCRixtQkFBT0EsQ0FBQyxtRkFBTTtBQUNqRCxJQUFJSyxVQUFVTCxtQkFBT0EsQ0FBQyxzRkFBZ0I7QUFDdEMsSUFBSU0sZUFBZU4sbUJBQU9BLENBQUMsZ0dBQXFCO0FBQ2hELElBQUlPLFNBQVNQLG1CQUFPQSxDQUFDLG9GQUFlO0FBQ3BDLElBQUlKLGlCQUFpQk0sdUJBQXVCRixtQkFBT0EsQ0FBQyx3RkFBaUI7QUFDckUsSUFBSVEsT0FBT04sdUJBQXVCRixtQkFBT0EsQ0FBQyxnRkFBYTtBQUN2RCxTQUFTRSx1QkFBdUJPLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRVosU0FBU1k7SUFBSTtBQUFHO0FBQzlGLFNBQVNFLHlCQUF5QkMsV0FBVztJQUFJLElBQUksT0FBT0MsWUFBWSxZQUFZLE9BQU87SUFBTSxJQUFJQyxvQkFBb0IsSUFBSUQ7SUFBVyxJQUFJRSxtQkFBbUIsSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFVQyxXQUFXO1FBQUksT0FBT0EsY0FBY0csbUJBQW1CRDtJQUFtQixHQUFHRjtBQUFjO0FBQ3RULFNBQVNiLHdCQUF3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QztRQUN0RjVFLEdBQUczRCxXQUFXSixPQUFPLENBQUNvSSxTQUFTLENBQUM7WUFBQ2hJLFdBQVdKLE9BQU8sQ0FBQ3VJLE1BQU07WUFBRW5JLFdBQVdKLE9BQU8sQ0FBQzJJLE1BQU07U0FBQztJQUN4RjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUJDLEdBQ0QvRSxVQUFVeEQsV0FBV0osT0FBTyxDQUFDcUksS0FBSyxDQUFDO1FBQ2pDdkUsR0FBRzFELFdBQVdKLE9BQU8sQ0FBQ3VJLE1BQU07UUFDNUJ4RSxHQUFHM0QsV0FBV0osT0FBTyxDQUFDdUksTUFBTTtJQUM5QjtJQUNBOztHQUVDLEdBQ0RiLFdBQVdoSCxPQUFPa0ksU0FBUztJQUMzQjNCLE9BQU92RyxPQUFPa0ksU0FBUztJQUN2QlgsV0FBV3ZILE9BQU9rSSxTQUFTO0FBQzdCO0FBQ0FyRyxnQkFBZ0JnQixXQUFXLGdCQUFnQjtJQUN6QyxHQUFHeEQsZUFBZUMsT0FBTyxDQUFDNkksWUFBWTtJQUN0Q3BDLE1BQU07SUFDTjFCLFFBQVE7SUFDUjRCLGtCQUFrQjtJQUNsQkMsMEJBQTBCO0lBQzFCQyx5QkFBeUI7SUFDekJsQixpQkFBaUI7UUFDZjdCLEdBQUc7UUFDSEMsR0FBRztJQUNMO0lBQ0FnRCxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmFzb3JfY2xvbmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGUuanM/N2UyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRyYWdnYWJsZUNvcmVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX0RyYWdnYWJsZUNvcmUuZGVmYXVsdDtcbiAgfVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX2RvbUZucyA9IHJlcXVpcmUoXCIuL3V0aWxzL2RvbUZuc1wiKTtcbnZhciBfcG9zaXRpb25GbnMgPSByZXF1aXJlKFwiLi91dGlscy9wb3NpdGlvbkZuc1wiKTtcbnZhciBfc2hpbXMgPSByZXF1aXJlKFwiLi91dGlscy9zaGltc1wiKTtcbnZhciBfRHJhZ2dhYmxlQ29yZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRHJhZ2dhYmxlQ29yZVwiKSk7XG52YXIgX2xvZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvbG9nXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfSAvKjo6IGltcG9ydCB0eXBlIHtDb250cm9sUG9zaXRpb24sIFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uLCBEcmFnZ2FibGVDb3JlUHJvcHMsIERyYWdnYWJsZUNvcmVEZWZhdWx0UHJvcHN9IGZyb20gJy4vRHJhZ2dhYmxlQ29yZSc7Ki9cbi8qOjogaW1wb3J0IHR5cGUge0JvdW5kcywgRHJhZ2dhYmxlRXZlbnRIYW5kbGVyfSBmcm9tICcuL3V0aWxzL3R5cGVzJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7RWxlbWVudCBhcyBSZWFjdEVsZW1lbnR9IGZyb20gJ3JlYWN0JzsqL1xuLyo6OiB0eXBlIERyYWdnYWJsZVN0YXRlID0ge1xuICBkcmFnZ2luZzogYm9vbGVhbixcbiAgZHJhZ2dlZDogYm9vbGVhbixcbiAgeDogbnVtYmVyLCB5OiBudW1iZXIsXG4gIHNsYWNrWDogbnVtYmVyLCBzbGFja1k6IG51bWJlcixcbiAgaXNFbGVtZW50U1ZHOiBib29sZWFuLFxuICBwcmV2UHJvcHNQb3NpdGlvbjogP0NvbnRyb2xQb3NpdGlvbixcbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ2dhYmxlRGVmYXVsdFByb3BzID0ge1xuICAuLi5EcmFnZ2FibGVDb3JlRGVmYXVsdFByb3BzLFxuICBheGlzOiAnYm90aCcgfCAneCcgfCAneScgfCAnbm9uZScsXG4gIGJvdW5kczogQm91bmRzIHwgc3RyaW5nIHwgZmFsc2UsXG4gIGRlZmF1bHRDbGFzc05hbWU6IHN0cmluZyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nOiBzdHJpbmcsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkOiBzdHJpbmcsXG4gIGRlZmF1bHRQb3NpdGlvbjogQ29udHJvbFBvc2l0aW9uLFxuICBzY2FsZTogbnVtYmVyLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVQcm9wcyA9IHtcbiAgLi4uRHJhZ2dhYmxlQ29yZVByb3BzLFxuICAuLi5EcmFnZ2FibGVEZWZhdWx0UHJvcHMsXG4gIHBvc2l0aW9uT2Zmc2V0OiBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbixcbiAgcG9zaXRpb246IENvbnRyb2xQb3NpdGlvbixcbn07Ki9cbi8vXG4vLyBEZWZpbmUgPERyYWdnYWJsZT5cbi8vXG5jbGFzcyBEcmFnZ2FibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgLyo6OiA8RHJhZ2dhYmxlUHJvcHMsIERyYWdnYWJsZVN0YXRlPiove1xuICAvLyBSZWFjdCAxNi4zK1xuICAvLyBBcml0eSAocHJvcHMsIHN0YXRlKVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKF9yZWYgLyo6OiAqLywgX3JlZjIgLyo6OiAqLykgLyo6ID9QYXJ0aWFsPERyYWdnYWJsZVN0YXRlPiove1xuICAgIGxldCB7XG4gICAgICBwb3NpdGlvblxuICAgIH0gLyo6IERyYWdnYWJsZVByb3BzKi8gPSBfcmVmIC8qOiBEcmFnZ2FibGVQcm9wcyovO1xuICAgIGxldCB7XG4gICAgICBwcmV2UHJvcHNQb3NpdGlvblxuICAgIH0gLyo6IERyYWdnYWJsZVN0YXRlKi8gPSBfcmVmMiAvKjogRHJhZ2dhYmxlU3RhdGUqLztcbiAgICAvLyBTZXQgeC95IGlmIGEgbmV3IHBvc2l0aW9uIGlzIHByb3ZpZGVkIGluIHByb3BzIHRoYXQgaXMgZGlmZmVyZW50IHRoYW4gdGhlIHByZXZpb3VzLlxuICAgIGlmIChwb3NpdGlvbiAmJiAoIXByZXZQcm9wc1Bvc2l0aW9uIHx8IHBvc2l0aW9uLnggIT09IHByZXZQcm9wc1Bvc2l0aW9uLnggfHwgcG9zaXRpb24ueSAhPT0gcHJldlByb3BzUG9zaXRpb24ueSkpIHtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGU6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAlaicsIHtcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIHByZXZQcm9wc1Bvc2l0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgIHk6IHBvc2l0aW9uLnksXG4gICAgICAgIHByZXZQcm9wc1Bvc2l0aW9uOiB7XG4gICAgICAgICAgLi4ucG9zaXRpb25cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3RydWN0b3IocHJvcHMgLyo6IERyYWdnYWJsZVByb3BzKi8pIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnU3RhcnRcIiwgKGUsIGNvcmVEYXRhKSA9PiB7XG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlOiBvbkRyYWdTdGFydDogJWonLCBjb3JlRGF0YSk7XG5cbiAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgdXNlcidzIGNhbGxiYWNrIGtpbGxlZCBpdC5cbiAgICAgIGNvbnN0IHNob3VsZFN0YXJ0ID0gdGhpcy5wcm9wcy5vblN0YXJ0KGUsICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkodGhpcywgY29yZURhdGEpKTtcbiAgICAgIC8vIEtpbGxzIHN0YXJ0IGV2ZW50IG9uIGNvcmUgYXMgd2VsbCwgc28gbW92ZSBoYW5kbGVycyBhcmUgbmV2ZXIgYm91bmQuXG4gICAgICBpZiAoc2hvdWxkU3RhcnQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZHJhZ2dpbmc6IHRydWUsXG4gICAgICAgIGRyYWdnZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1wiLCAoZSwgY29yZURhdGEpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5kcmFnZ2luZykgcmV0dXJuIGZhbHNlO1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZTogb25EcmFnOiAlaicsIGNvcmVEYXRhKTtcbiAgICAgIGNvbnN0IHVpRGF0YSA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkodGhpcywgY29yZURhdGEpO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgIHg6IHVpRGF0YS54LFxuICAgICAgICB5OiB1aURhdGEueSxcbiAgICAgICAgc2xhY2tYOiAwLFxuICAgICAgICBzbGFja1k6IDBcbiAgICAgIH07XG5cbiAgICAgIC8vIEtlZXAgd2l0aGluIGJvdW5kcy5cbiAgICAgIGlmICh0aGlzLnByb3BzLmJvdW5kcykge1xuICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIHggYW5kIHkuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IG5ld1N0YXRlO1xuXG4gICAgICAgIC8vIEFkZCBzbGFjayB0byB0aGUgdmFsdWVzIHVzZWQgdG8gY2FsY3VsYXRlIGJvdW5kIHBvc2l0aW9uLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgaWZcbiAgICAgICAgLy8gd2Ugc3RhcnQgcmVtb3Zpbmcgc2xhY2ssIHRoZSBlbGVtZW50IHdvbid0IHJlYWN0IHRvIGl0IHJpZ2h0IGF3YXkgdW50aWwgaXQncyBiZWVuXG4gICAgICAgIC8vIGNvbXBsZXRlbHkgcmVtb3ZlZC5cbiAgICAgICAgbmV3U3RhdGUueCArPSB0aGlzLnN0YXRlLnNsYWNrWDtcbiAgICAgICAgbmV3U3RhdGUueSArPSB0aGlzLnN0YXRlLnNsYWNrWTtcblxuICAgICAgICAvLyBHZXQgYm91bmQgcG9zaXRpb24uIFRoaXMgd2lsbCBjZWlsL2Zsb29yIHRoZSB4IGFuZCB5IHdpdGhpbiB0aGUgYm91bmRhcmllcy5cbiAgICAgICAgY29uc3QgW25ld1N0YXRlWCwgbmV3U3RhdGVZXSA9ICgwLCBfcG9zaXRpb25GbnMuZ2V0Qm91bmRQb3NpdGlvbikodGhpcywgbmV3U3RhdGUueCwgbmV3U3RhdGUueSk7XG4gICAgICAgIG5ld1N0YXRlLnggPSBuZXdTdGF0ZVg7XG4gICAgICAgIG5ld1N0YXRlLnkgPSBuZXdTdGF0ZVk7XG5cbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgc2xhY2sgYnkgbm90aW5nIGhvdyBtdWNoIHdhcyBzaGF2ZWQgYnkgdGhlIGJvdW5kUG9zaXRpb24gaGFuZGxlci5cbiAgICAgICAgbmV3U3RhdGUuc2xhY2tYID0gdGhpcy5zdGF0ZS5zbGFja1ggKyAoeCAtIG5ld1N0YXRlLngpO1xuICAgICAgICBuZXdTdGF0ZS5zbGFja1kgPSB0aGlzLnN0YXRlLnNsYWNrWSArICh5IC0gbmV3U3RhdGUueSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBldmVudCB3ZSBmaXJlIHRvIHJlZmxlY3Qgd2hhdCByZWFsbHkgaGFwcGVuZWQgYWZ0ZXIgYm91bmRzIHRvb2sgZWZmZWN0LlxuICAgICAgICB1aURhdGEueCA9IG5ld1N0YXRlLng7XG4gICAgICAgIHVpRGF0YS55ID0gbmV3U3RhdGUueTtcbiAgICAgICAgdWlEYXRhLmRlbHRhWCA9IG5ld1N0YXRlLnggLSB0aGlzLnN0YXRlLng7XG4gICAgICAgIHVpRGF0YS5kZWx0YVkgPSBuZXdTdGF0ZS55IC0gdGhpcy5zdGF0ZS55O1xuICAgICAgfVxuXG4gICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHVzZXIncyBjYWxsYmFjayBraWxsZWQgaXQuXG4gICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSB0aGlzLnByb3BzLm9uRHJhZyhlLCB1aURhdGEpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1N0b3BcIiwgKGUsIGNvcmVEYXRhKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuZHJhZ2dpbmcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gU2hvcnQtY2lyY3VpdCBpZiB1c2VyJ3MgY2FsbGJhY2sga2lsbGVkIGl0LlxuICAgICAgY29uc3Qgc2hvdWxkQ29udGludWUgPSB0aGlzLnByb3BzLm9uU3RvcChlLCAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZURyYWdnYWJsZURhdGEpKHRoaXMsIGNvcmVEYXRhKSk7XG4gICAgICBpZiAoc2hvdWxkQ29udGludWUgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlOiBvbkRyYWdTdG9wOiAlaicsIGNvcmVEYXRhKTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlIC8qOiBQYXJ0aWFsPERyYWdnYWJsZVN0YXRlPiovID0ge1xuICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIHNsYWNrWDogMCxcbiAgICAgICAgc2xhY2tZOiAwXG4gICAgICB9O1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCBjb21wb25lbnQsIHRoZSByZXN1bHQgb2YgdGhpcyBvcGVyYXRpb24gd2lsbCBiZSB0b1xuICAgICAgLy8gcmV2ZXJ0IGJhY2sgdG8gdGhlIG9sZCBwb3NpdGlvbi4gV2UgZXhwZWN0IGEgaGFuZGxlciBvbiBgb25EcmFnU3RvcGAsIGF0IHRoZSBsZWFzdC5cbiAgICAgIGNvbnN0IGNvbnRyb2xsZWQgPSBCb29sZWFuKHRoaXMucHJvcHMucG9zaXRpb24pO1xuICAgICAgaWYgKGNvbnRyb2xsZWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gdGhpcy5wcm9wcy5wb3NpdGlvbjtcbiAgICAgICAgbmV3U3RhdGUueCA9IHg7XG4gICAgICAgIG5ld1N0YXRlLnkgPSB5O1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBjdXJyZW50bHkgZHJhZ2dpbmcuXG4gICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAvLyBXaGV0aGVyIG9yIG5vdCB3ZSBoYXZlIGJlZW4gZHJhZ2dlZCBiZWZvcmUuXG4gICAgICBkcmFnZ2VkOiBmYWxzZSxcbiAgICAgIC8vIEN1cnJlbnQgdHJhbnNmb3JtIHggYW5kIHkuXG4gICAgICB4OiBwcm9wcy5wb3NpdGlvbiA/IHByb3BzLnBvc2l0aW9uLnggOiBwcm9wcy5kZWZhdWx0UG9zaXRpb24ueCxcbiAgICAgIHk6IHByb3BzLnBvc2l0aW9uID8gcHJvcHMucG9zaXRpb24ueSA6IHByb3BzLmRlZmF1bHRQb3NpdGlvbi55LFxuICAgICAgcHJldlByb3BzUG9zaXRpb246IHtcbiAgICAgICAgLi4ucHJvcHMucG9zaXRpb25cbiAgICAgIH0sXG4gICAgICAvLyBVc2VkIGZvciBjb21wZW5zYXRpbmcgZm9yIG91dC1vZi1ib3VuZHMgZHJhZ3NcbiAgICAgIHNsYWNrWDogMCxcbiAgICAgIHNsYWNrWTogMCxcbiAgICAgIC8vIENhbiBvbmx5IGRldGVybWluZSBpZiBTVkcgYWZ0ZXIgbW91bnRpbmdcbiAgICAgIGlzRWxlbWVudFNWRzogZmFsc2VcbiAgICB9O1xuICAgIGlmIChwcm9wcy5wb3NpdGlvbiAmJiAhKHByb3BzLm9uRHJhZyB8fCBwcm9wcy5vblN0b3ApKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKCdBIGBwb3NpdGlvbmAgd2FzIGFwcGxpZWQgdG8gdGhpcyA8RHJhZ2dhYmxlPiwgd2l0aG91dCBkcmFnIGhhbmRsZXJzLiBUaGlzIHdpbGwgbWFrZSB0aGlzICcgKyAnY29tcG9uZW50IGVmZmVjdGl2ZWx5IHVuZHJhZ2dhYmxlLiBQbGVhc2UgYXR0YWNoIGBvbkRyYWdgIG9yIGBvblN0b3BgIGhhbmRsZXJzIHNvIHlvdSBjYW4gYWRqdXN0IHRoZSAnICsgJ2Bwb3NpdGlvbmAgb2YgdGhpcyBlbGVtZW50LicpO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGVsZW1lbnQgcGFzc2VkIGlzIGFuIGluc3RhbmNlb2YgU1ZHRWxlbWVudFxuICAgIGlmICh0eXBlb2Ygd2luZG93LlNWR0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuZmluZERPTU5vZGUoKSBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50KSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNFbGVtZW50U1ZHOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkcmFnZ2luZzogZmFsc2VcbiAgICB9KTsgLy8gcHJldmVudHMgaW52YXJpYW50IGlmIHVubW91bnRlZCB3aGlsZSBkcmFnZ2luZ1xuICB9XG5cbiAgLy8gUmVhY3QgU3RyaWN0IE1vZGUgY29tcGF0aWJpbGl0eTogaWYgYG5vZGVSZWZgIGlzIHBhc3NlZCwgd2Ugd2lsbCB1c2UgaXQgaW5zdGVhZCBvZiB0cnlpbmcgdG8gZmluZFxuICAvLyB0aGUgdW5kZXJseWluZyBET00gbm9kZSBvdXJzZWx2ZXMuIFNlZSB0aGUgUkVBRE1FIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICBmaW5kRE9NTm9kZSgpIC8qOiA/SFRNTEVsZW1lbnQqL3tcbiAgICB2YXIgX3RoaXMkcHJvcHMkbm9kZVJlZiRjLCBfdGhpcyRwcm9wcztcbiAgICByZXR1cm4gKF90aGlzJHByb3BzJG5vZGVSZWYkYyA9IChfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMpID09PSBudWxsIHx8IF90aGlzJHByb3BzID09PSB2b2lkIDAgfHwgKF90aGlzJHByb3BzID0gX3RoaXMkcHJvcHMubm9kZVJlZikgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHByb3BzLmN1cnJlbnQpICE9PSBudWxsICYmIF90aGlzJHByb3BzJG5vZGVSZWYkYyAhPT0gdm9pZCAwID8gX3RoaXMkcHJvcHMkbm9kZVJlZiRjIDogX3JlYWN0RG9tLmRlZmF1bHQuZmluZERPTU5vZGUodGhpcyk7XG4gIH1cbiAgcmVuZGVyKCkgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki97XG4gICAgY29uc3Qge1xuICAgICAgYXhpcyxcbiAgICAgIGJvdW5kcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZGVmYXVsdFBvc2l0aW9uLFxuICAgICAgZGVmYXVsdENsYXNzTmFtZSxcbiAgICAgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZyxcbiAgICAgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBwb3NpdGlvbk9mZnNldCxcbiAgICAgIHNjYWxlLFxuICAgICAgLi4uZHJhZ2dhYmxlQ29yZVByb3BzXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHN0eWxlID0ge307XG4gICAgbGV0IHN2Z1RyYW5zZm9ybSA9IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGNvbnRyb2xsZWQsIHdlIGRvbid0IHdhbnQgdG8gbW92ZSBpdCAtIHVubGVzcyBpdCdzIGRyYWdnaW5nLlxuICAgIGNvbnN0IGNvbnRyb2xsZWQgPSBCb29sZWFuKHBvc2l0aW9uKTtcbiAgICBjb25zdCBkcmFnZ2FibGUgPSAhY29udHJvbGxlZCB8fCB0aGlzLnN0YXRlLmRyYWdnaW5nO1xuICAgIGNvbnN0IHZhbGlkUG9zaXRpb24gPSBwb3NpdGlvbiB8fCBkZWZhdWx0UG9zaXRpb247XG4gICAgY29uc3QgdHJhbnNmb3JtT3B0cyA9IHtcbiAgICAgIC8vIFNldCBsZWZ0IGlmIGhvcml6b250YWwgZHJhZyBpcyBlbmFibGVkXG4gICAgICB4OiAoMCwgX3Bvc2l0aW9uRm5zLmNhbkRyYWdYKSh0aGlzKSAmJiBkcmFnZ2FibGUgPyB0aGlzLnN0YXRlLnggOiB2YWxpZFBvc2l0aW9uLngsXG4gICAgICAvLyBTZXQgdG9wIGlmIHZlcnRpY2FsIGRyYWcgaXMgZW5hYmxlZFxuICAgICAgeTogKDAsIF9wb3NpdGlvbkZucy5jYW5EcmFnWSkodGhpcykgJiYgZHJhZ2dhYmxlID8gdGhpcy5zdGF0ZS55IDogdmFsaWRQb3NpdGlvbi55XG4gICAgfTtcblxuICAgIC8vIElmIHRoaXMgZWxlbWVudCB3YXMgU1ZHLCB3ZSB1c2UgdGhlIGB0cmFuc2Zvcm1gIGF0dHJpYnV0ZS5cbiAgICBpZiAodGhpcy5zdGF0ZS5pc0VsZW1lbnRTVkcpIHtcbiAgICAgIHN2Z1RyYW5zZm9ybSA9ICgwLCBfZG9tRm5zLmNyZWF0ZVNWR1RyYW5zZm9ybSkodHJhbnNmb3JtT3B0cywgcG9zaXRpb25PZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGQgYSBDU1MgdHJhbnNmb3JtIHRvIG1vdmUgdGhlIGVsZW1lbnQgYXJvdW5kLiBUaGlzIGFsbG93cyB1cyB0byBtb3ZlIHRoZSBlbGVtZW50IGFyb3VuZFxuICAgICAgLy8gd2l0aG91dCB3b3JyeWluZyBhYm91dCB3aGV0aGVyIG9yIG5vdCBpdCBpcyByZWxhdGl2ZWx5IG9yIGFic29sdXRlbHkgcG9zaXRpb25lZC5cbiAgICAgIC8vIElmIHRoZSBpdGVtIHlvdSBhcmUgZHJhZ2dpbmcgYWxyZWFkeSBoYXMgYSB0cmFuc2Zvcm0gc2V0LCB3cmFwIGl0IGluIGEgPHNwYW4+IHNvIDxEcmFnZ2FibGU+XG4gICAgICAvLyBoYXMgYSBjbGVhbiBzbGF0ZS5cbiAgICAgIHN0eWxlID0gKDAsIF9kb21GbnMuY3JlYXRlQ1NTVHJhbnNmb3JtKSh0cmFuc2Zvcm1PcHRzLCBwb3NpdGlvbk9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gTWFyayB3aXRoIGNsYXNzIHdoaWxlIGRyYWdnaW5nXG4gICAgY29uc3QgY2xhc3NOYW1lID0gKDAsIF9jbHN4LmRlZmF1bHQpKGNoaWxkcmVuLnByb3BzLmNsYXNzTmFtZSB8fCAnJywgZGVmYXVsdENsYXNzTmFtZSwge1xuICAgICAgW2RlZmF1bHRDbGFzc05hbWVEcmFnZ2luZ106IHRoaXMuc3RhdGUuZHJhZ2dpbmcsXG4gICAgICBbZGVmYXVsdENsYXNzTmFtZURyYWdnZWRdOiB0aGlzLnN0YXRlLmRyYWdnZWRcbiAgICB9KTtcblxuICAgIC8vIFJldXNlIHRoZSBjaGlsZCBwcm92aWRlZFxuICAgIC8vIFRoaXMgbWFrZXMgaXQgZmxleGlibGUgdG8gdXNlIHdoYXRldmVyIGVsZW1lbnQgaXMgd2FudGVkIChkaXYsIHVsLCBldGMpXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9EcmFnZ2FibGVDb3JlLmRlZmF1bHQsIF9leHRlbmRzKHt9LCBkcmFnZ2FibGVDb3JlUHJvcHMsIHtcbiAgICAgIG9uU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQsXG4gICAgICBvbkRyYWc6IHRoaXMub25EcmFnLFxuICAgICAgb25TdG9wOiB0aGlzLm9uRHJhZ1N0b3BcbiAgICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICBzdHlsZToge1xuICAgICAgICAuLi5jaGlsZHJlbi5wcm9wcy5zdHlsZSxcbiAgICAgICAgLi4uc3R5bGVcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IHN2Z1RyYW5zZm9ybVxuICAgIH0pKTtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZSwgXCJkaXNwbGF5TmFtZVwiLCAnRHJhZ2dhYmxlJyk7XG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlLCBcInByb3BUeXBlc1wiLCB7XG4gIC8vIEFjY2VwdHMgYWxsIHByb3BzIDxEcmFnZ2FibGVDb3JlPiBhY2NlcHRzLlxuICAuLi5fRHJhZ2dhYmxlQ29yZS5kZWZhdWx0LnByb3BUeXBlcyxcbiAgLyoqXG4gICAqIGBheGlzYCBkZXRlcm1pbmVzIHdoaWNoIGF4aXMgdGhlIGRyYWdnYWJsZSBjYW4gbW92ZS5cbiAgICpcbiAgICogIE5vdGUgdGhhdCBhbGwgY2FsbGJhY2tzIHdpbGwgc3RpbGwgcmV0dXJuIGRhdGEgYXMgbm9ybWFsLiBUaGlzIG9ubHlcbiAgICogIGNvbnRyb2xzIGZsdXNoaW5nIHRvIHRoZSBET00uXG4gICAqXG4gICAqICdib3RoJyBhbGxvd3MgbW92ZW1lbnQgaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5LlxuICAgKiAneCcgbGltaXRzIG1vdmVtZW50IHRvIGhvcml6b250YWwgYXhpcy5cbiAgICogJ3knIGxpbWl0cyBtb3ZlbWVudCB0byB2ZXJ0aWNhbCBheGlzLlxuICAgKiAnbm9uZScgbGltaXRzIGFsbCBtb3ZlbWVudC5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gJ2JvdGgnLlxuICAgKi9cbiAgYXhpczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFsnYm90aCcsICd4JywgJ3knLCAnbm9uZSddKSxcbiAgLyoqXG4gICAqIGBib3VuZHNgIGRldGVybWluZXMgdGhlIHJhbmdlIG9mIG1vdmVtZW50IGF2YWlsYWJsZSB0byB0aGUgZWxlbWVudC5cbiAgICogQXZhaWxhYmxlIHZhbHVlcyBhcmU6XG4gICAqXG4gICAqICdwYXJlbnQnIHJlc3RyaWN0cyBtb3ZlbWVudCB3aXRoaW4gdGhlIERyYWdnYWJsZSdzIHBhcmVudCBub2RlLlxuICAgKlxuICAgKiBBbHRlcm5hdGl2ZWx5LCBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcywgYWxsIG9mIHdoaWNoIGFyZSBvcHRpb25hbDpcbiAgICpcbiAgICoge2xlZnQ6IExFRlRfQk9VTkQsIHJpZ2h0OiBSSUdIVF9CT1VORCwgYm90dG9tOiBCT1RUT01fQk9VTkQsIHRvcDogVE9QX0JPVU5EfVxuICAgKlxuICAgKiBBbGwgdmFsdWVzIGFyZSBpbiBweC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgcmV0dXJuIChcbiAgICogICAgICAgICAgICA8RHJhZ2dhYmxlIGJvdW5kcz17e3JpZ2h0OiAzMDAsIGJvdHRvbTogMzAwfX0+XG4gICAqICAgICAgICAgICAgICA8ZGl2PkNvbnRlbnQ8L2Rpdj5cbiAgICogICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBib3VuZHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgbGVmdDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICByaWdodDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgYm90dG9tOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLCBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoW2ZhbHNlXSldKSxcbiAgZGVmYXVsdENsYXNzTmFtZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLyoqXG4gICAqIGBkZWZhdWx0UG9zaXRpb25gIHNwZWNpZmllcyB0aGUgeCBhbmQgeSB0aGF0IHRoZSBkcmFnZ2VkIGl0ZW0gc2hvdWxkIHN0YXJ0IGF0XG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiAgICAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgKiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICogICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIGRlZmF1bHRQb3NpdGlvbj17e3g6IDI1LCB5OiAyNX19PlxuICAgKiAgICAgICAgICAgICAgICAgICAgICA8ZGl2Pkkgc3RhcnQgd2l0aCB0cmFuc2Zvcm1YOiAyNXB4IGFuZCB0cmFuc2Zvcm1ZOiAyNXB4OzwvZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICAgICAgKTtcbiAgICogICAgICAgICAgfVxuICAgKiAgICAgIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGRlZmF1bHRQb3NpdGlvbjogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICB4OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHk6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbiAgfSksXG4gIHBvc2l0aW9uT2Zmc2V0OiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIHg6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmddKSxcbiAgICB5OiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nXSlcbiAgfSksXG4gIC8qKlxuICAgKiBgcG9zaXRpb25gLCBpZiBwcmVzZW50LCBkZWZpbmVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiAgVGhpcyBpcyBzaW1pbGFyIHRvIGhvdyBmb3JtIGVsZW1lbnRzIGluIFJlYWN0IHdvcmsgLSBpZiBubyBgcG9zaXRpb25gIGlzIHN1cHBsaWVkLCB0aGUgY29tcG9uZW50XG4gICAqICBpcyB1bmNvbnRyb2xsZWQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiAgICAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgKiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICogICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIHBvc2l0aW9uPXt7eDogMjUsIHk6IDI1fX0+XG4gICAqICAgICAgICAgICAgICAgICAgICAgIDxkaXY+SSBzdGFydCB3aXRoIHRyYW5zZm9ybVg6IDI1cHggYW5kIHRyYW5zZm9ybVk6IDI1cHg7PC9kaXY+XG4gICAqICAgICAgICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgICAgICAgICAgICApO1xuICAgKiAgICAgICAgICB9XG4gICAqICAgICAgfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgcG9zaXRpb246IF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgeDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB5OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLFxuICAvKipcbiAgICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgYmUgZGVmaW5lZCBvbiB0aGUgY2hpbGQsIG5vdCBoZXJlLlxuICAgKi9cbiAgY2xhc3NOYW1lOiBfc2hpbXMuZG9udFNldE1lLFxuICBzdHlsZTogX3NoaW1zLmRvbnRTZXRNZSxcbiAgdHJhbnNmb3JtOiBfc2hpbXMuZG9udFNldE1lXG59KTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGUsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgLi4uX0RyYWdnYWJsZUNvcmUuZGVmYXVsdC5kZWZhdWx0UHJvcHMsXG4gIGF4aXM6ICdib3RoJyxcbiAgYm91bmRzOiBmYWxzZSxcbiAgZGVmYXVsdENsYXNzTmFtZTogJ3JlYWN0LWRyYWdnYWJsZScsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZzogJ3JlYWN0LWRyYWdnYWJsZS1kcmFnZ2luZycsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkOiAncmVhY3QtZHJhZ2dhYmxlLWRyYWdnZWQnLFxuICBkZWZhdWx0UG9zaXRpb246IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSxcbiAgc2NhbGU6IDFcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfRHJhZ2dhYmxlQ29yZSIsImRlZmF1bHQiLCJSZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9wcm9wVHlwZXMiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3JlYWN0RG9tIiwiX2Nsc3giLCJfZG9tRm5zIiwiX3Bvc2l0aW9uRm5zIiwiX3NoaW1zIiwiX2xvZyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJub2RlSW50ZXJvcCIsIldlYWtNYXAiLCJjYWNoZUJhYmVsSW50ZXJvcCIsImNhY2hlTm9kZUludGVyb3AiLCJjYWNoZSIsImhhcyIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlc2MiLCJzZXQiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiYXBwbHkiLCJfZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiYXJnIiwiX3RvUHJpbWl0aXZlIiwiU3RyaW5nIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwidW5kZWZpbmVkIiwicmVzIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiRHJhZ2dhYmxlIiwiQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiX3JlZiIsIl9yZWYyIiwicG9zaXRpb24iLCJwcmV2UHJvcHNQb3NpdGlvbiIsIngiLCJ5IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImUiLCJjb3JlRGF0YSIsInNob3VsZFN0YXJ0Iiwib25TdGFydCIsImNyZWF0ZURyYWdnYWJsZURhdGEiLCJzZXRTdGF0ZSIsImRyYWdnaW5nIiwiZHJhZ2dlZCIsInN0YXRlIiwidWlEYXRhIiwibmV3U3RhdGUiLCJzbGFja1giLCJzbGFja1kiLCJib3VuZHMiLCJuZXdTdGF0ZVgiLCJuZXdTdGF0ZVkiLCJnZXRCb3VuZFBvc2l0aW9uIiwiZGVsdGFYIiwiZGVsdGFZIiwic2hvdWxkVXBkYXRlIiwib25EcmFnIiwic2hvdWxkQ29udGludWUiLCJvblN0b3AiLCJjb250cm9sbGVkIiwiQm9vbGVhbiIsImRlZmF1bHRQb3NpdGlvbiIsImlzRWxlbWVudFNWRyIsImNvbnNvbGUiLCJ3YXJuIiwiY29tcG9uZW50RGlkTW91bnQiLCJ3aW5kb3ciLCJTVkdFbGVtZW50IiwiZmluZERPTU5vZGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIl90aGlzJHByb3BzJG5vZGVSZWYkYyIsIl90aGlzJHByb3BzIiwibm9kZVJlZiIsImN1cnJlbnQiLCJyZW5kZXIiLCJheGlzIiwiY2hpbGRyZW4iLCJkZWZhdWx0Q2xhc3NOYW1lIiwiZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nIiwiZGVmYXVsdENsYXNzTmFtZURyYWdnZWQiLCJwb3NpdGlvbk9mZnNldCIsInNjYWxlIiwiZHJhZ2dhYmxlQ29yZVByb3BzIiwic3R5bGUiLCJzdmdUcmFuc2Zvcm0iLCJkcmFnZ2FibGUiLCJ2YWxpZFBvc2l0aW9uIiwidHJhbnNmb3JtT3B0cyIsImNhbkRyYWdYIiwiY2FuRHJhZ1kiLCJjcmVhdGVTVkdUcmFuc2Zvcm0iLCJjcmVhdGVDU1NUcmFuc2Zvcm0iLCJjbGFzc05hbWUiLCJjcmVhdGVFbGVtZW50Iiwib25EcmFnU3RhcnQiLCJvbkRyYWdTdG9wIiwiY2xvbmVFbGVtZW50IiwiQ2hpbGRyZW4iLCJvbmx5IiwidHJhbnNmb3JtIiwicHJvcFR5cGVzIiwib25lT2YiLCJvbmVPZlR5cGUiLCJzaGFwZSIsImxlZnQiLCJudW1iZXIiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsInN0cmluZyIsImRvbnRTZXRNZSIsImRlZmF1bHRQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/Draggable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/DraggableCore.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/DraggableCore.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"));\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\n/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ // Simple abstraction for dragging events names.\nconst eventsFor = {\n    touch: {\n        start: \"touchstart\",\n        move: \"touchmove\",\n        stop: \"touchend\"\n    },\n    mouse: {\n        start: \"mousedown\",\n        move: \"mousemove\",\n        stop: \"mouseup\"\n    }\n};\n// Default to mouse events.\nlet dragEventFor = eventsFor.mouse;\n/*:: export type DraggableData = {\n  node: HTMLElement,\n  x: number, y: number,\n  deltaX: number, deltaY: number,\n  lastX: number, lastY: number,\n};*/ /*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/ /*:: export type ControlPosition = {x: number, y: number};*/ /*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/ /*:: export type DraggableCoreDefaultProps = {\n  allowAnyClick: boolean,\n  disabled: boolean,\n  enableUserSelectHack: boolean,\n  onStart: DraggableEventHandler,\n  onDrag: DraggableEventHandler,\n  onStop: DraggableEventHandler,\n  onMouseDown: (e: MouseEvent) => void,\n  scale: number,\n};*/ /*:: export type DraggableCoreProps = {\n  ...DraggableCoreDefaultProps,\n  cancel: string,\n  children: ReactElement<any>,\n  offsetParent: HTMLElement,\n  grid: [number, number],\n  handle: string,\n  nodeRef?: ?React.ElementRef<any>,\n};*/ //\n// Define <DraggableCore>.\n//\n// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n// work well with libraries that require more control over the element.\n//\nclass DraggableCore extends React.Component /*:: <DraggableCoreProps>*/  {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"dragging\", false);\n        // Used while dragging to determine deltas.\n        _defineProperty(this, \"lastX\", NaN);\n        _defineProperty(this, \"lastY\", NaN);\n        _defineProperty(this, \"touchIdentifier\", null);\n        _defineProperty(this, \"mounted\", false);\n        _defineProperty(this, \"handleDragStart\", (e)=>{\n            // Make it possible to attach event handlers on top of this one.\n            this.props.onMouseDown(e);\n            // Only accept left-clicks.\n            if (!this.props.allowAnyClick && typeof e.button === \"number\" && e.button !== 0) return false;\n            // Get nodes. Be sure to grab relative document (could be iframed)\n            const thisNode = this.findDOMNode();\n            if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n                throw new Error(\"<DraggableCore> not mounted on DragStart!\");\n            }\n            const { ownerDocument } = thisNode;\n            // Short circuit if handle or cancel prop was provided and selector doesn't match.\n            if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {\n                return;\n            }\n            // Prevent scrolling on mobile devices, like ipad/iphone.\n            // Important that this is after handle/cancel.\n            if (e.type === \"touchstart\") e.preventDefault();\n            // Set touch identifier in component state if this is a touch event. This allows us to\n            // distinguish between individual touches on multitouch screens by identifying which\n            // touchpoint was set to this element.\n            const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);\n            this.touchIdentifier = touchIdentifier;\n            // Get the current drag point from the event. This is used as the offset.\n            const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);\n            if (position == null) return; // not possible but satisfies flow\n            const { x, y } = position;\n            // Create an event object with all the data parents need to make a decision here.\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            (0, _log.default)(\"DraggableCore: handleDragStart: %j\", coreEvent);\n            // Call event handler. If it returns explicit false, cancel.\n            (0, _log.default)(\"calling\", this.props.onStart);\n            const shouldUpdate = this.props.onStart(e, coreEvent);\n            if (shouldUpdate === false || this.mounted === false) return;\n            // Add a style to the body to disable user-select. This prevents text from\n            // being selected all over the page.\n            if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);\n            // Initiate dragging. Set the current x and y as offsets\n            // so we know how much we've moved during the drag. This allows us\n            // to drag elements around even if they have been moved, without issue.\n            this.dragging = true;\n            this.lastX = x;\n            this.lastY = y;\n            // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n            // this element. We use different events depending on whether or not we have detected that this\n            // is a touch-capable device.\n            (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);\n            (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);\n        });\n        _defineProperty(this, \"handleDrag\", (e)=>{\n            // Get the current drag point from the event. This is used as the offset.\n            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n            if (position == null) return;\n            let { x, y } = position;\n            // Snap to grid if prop has been provided\n            if (Array.isArray(this.props.grid)) {\n                let deltaX = x - this.lastX, deltaY = y - this.lastY;\n                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n                if (!deltaX && !deltaY) return; // skip useless drag\n                x = this.lastX + deltaX, y = this.lastY + deltaY;\n            }\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            (0, _log.default)(\"DraggableCore: handleDrag: %j\", coreEvent);\n            // Call event handler. If it returns explicit false, trigger end.\n            const shouldUpdate = this.props.onDrag(e, coreEvent);\n            if (shouldUpdate === false || this.mounted === false) {\n                try {\n                    // $FlowIgnore\n                    this.handleDragStop(new MouseEvent(\"mouseup\"));\n                } catch (err) {\n                    // Old browsers\n                    const event = document.createEvent(\"MouseEvents\");\n                    // I see why this insanity was deprecated\n                    // $FlowIgnore\n                    event.initMouseEvent(\"mouseup\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n                    this.handleDragStop(event);\n                }\n                return;\n            }\n            this.lastX = x;\n            this.lastY = y;\n        });\n        _defineProperty(this, \"handleDragStop\", (e)=>{\n            if (!this.dragging) return;\n            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n            if (position == null) return;\n            let { x, y } = position;\n            // Snap to grid if prop has been provided\n            if (Array.isArray(this.props.grid)) {\n                let deltaX = x - this.lastX || 0;\n                let deltaY = y - this.lastY || 0;\n                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n                x = this.lastX + deltaX, y = this.lastY + deltaY;\n            }\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            // Call event handler\n            const shouldContinue = this.props.onStop(e, coreEvent);\n            if (shouldContinue === false || this.mounted === false) return false;\n            const thisNode = this.findDOMNode();\n            if (thisNode) {\n                // Remove user-select hack\n                if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);\n            }\n            (0, _log.default)(\"DraggableCore: handleDragStop: %j\", coreEvent);\n            // Reset the el.\n            this.dragging = false;\n            this.lastX = NaN;\n            this.lastY = NaN;\n            if (thisNode) {\n                // Remove event handlers\n                (0, _log.default)(\"DraggableCore: Removing handlers\");\n                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\n                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\n            }\n        });\n        _defineProperty(this, \"onMouseDown\", (e)=>{\n            dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n            return this.handleDragStart(e);\n        });\n        _defineProperty(this, \"onMouseUp\", (e)=>{\n            dragEventFor = eventsFor.mouse;\n            return this.handleDragStop(e);\n        });\n        // Same as onMouseDown (start drag), but now consider this a touch device.\n        _defineProperty(this, \"onTouchStart\", (e)=>{\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return this.handleDragStart(e);\n        });\n        _defineProperty(this, \"onTouchEnd\", (e)=>{\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return this.handleDragStop(e);\n        });\n    }\n    componentDidMount() {\n        this.mounted = true;\n        // Touch handlers must be added with {passive: false} to be cancelable.\n        // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n        const thisNode = this.findDOMNode();\n        if (thisNode) {\n            (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n                passive: false\n            });\n        }\n    }\n    componentWillUnmount() {\n        this.mounted = false;\n        // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n        // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n        const thisNode = this.findDOMNode();\n        if (thisNode) {\n            const { ownerDocument } = thisNode;\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n                passive: false\n            });\n            if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);\n        }\n    }\n    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n    // the underlying DOM node ourselves. See the README for more information.\n    findDOMNode() /*: ?HTMLElement*/ {\n        var _this$props, _this$props2;\n        return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.nodeRef) === null || _this$props2 === void 0 ? void 0 : _this$props2.current : _reactDom.default.findDOMNode(this);\n    }\n    render() /*: React.Element<any>*/ {\n        // Reuse the child provided\n        // This makes it flexible to use whatever element is wanted (div, ul, etc)\n        return /*#__PURE__*/ React.cloneElement(React.Children.only(this.props.children), {\n            // Note: mouseMove handler is attached to document so it will still function\n            // when the user drags quickly and leaves the bounds of the element.\n            onMouseDown: this.onMouseDown,\n            onMouseUp: this.onMouseUp,\n            // onTouchStart is added on `componentDidMount` so they can be added with\n            // {passive: false}, which allows it to cancel. See\n            // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n            onTouchEnd: this.onTouchEnd\n        });\n    }\n}\nexports[\"default\"] = DraggableCore;\n_defineProperty(DraggableCore, \"displayName\", \"DraggableCore\");\n_defineProperty(DraggableCore, \"propTypes\", {\n    /**\n   * `allowAnyClick` allows dragging using any mouse button.\n   * By default, we only accept the left button.\n   *\n   * Defaults to `false`.\n   */ allowAnyClick: _propTypes.default.bool,\n    children: _propTypes.default.node.isRequired,\n    /**\n   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\n   * with the exception of `onMouseDown`, will not fire.\n   */ disabled: _propTypes.default.bool,\n    /**\n   * By default, we add 'user-select:none' attributes to the document body\n   * to prevent ugly text selection during drag. If this is causing problems\n   * for your app, set this to `false`.\n   */ enableUserSelectHack: _propTypes.default.bool,\n    /**\n   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\n   * instead of using the parent node.\n   */ offsetParent: function(props /*: DraggableCoreProps*/ , propName /*: $Keys<DraggableCoreProps>*/ ) {\n        if (props[propName] && props[propName].nodeType !== 1) {\n            throw new Error(\"Draggable's offsetParent must be a DOM Node.\");\n        }\n    },\n    /**\n   * `grid` specifies the x and y that dragging should snap to.\n   */ grid: _propTypes.default.arrayOf(_propTypes.default.number),\n    /**\n   * `handle` specifies a selector to be used as the handle that initiates drag.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable handle=\".handle\">\n   *              <div>\n   *                  <div className=\"handle\">Click me to drag</div>\n   *                  <div>This is some other content</div>\n   *              </div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */ handle: _propTypes.default.string,\n    /**\n   * `cancel` specifies a selector to be used to prevent drag initialization.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *           return(\n   *               <Draggable cancel=\".cancel\">\n   *                   <div>\n   *                     <div className=\"cancel\">You can't drag from here</div>\n   *                     <div>Dragging here works fine</div>\n   *                   </div>\n   *               </Draggable>\n   *           );\n   *       }\n   *   });\n   * ```\n   */ cancel: _propTypes.default.string,\n    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.\n   * Unfortunately, in order for <Draggable> to work properly, we need raw access\n   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`\n   * as in this example:\n   *\n   * function MyComponent() {\n   *   const nodeRef = React.useRef(null);\n   *   return (\n   *     <Draggable nodeRef={nodeRef}>\n   *       <div ref={nodeRef}>Example Target</div>\n   *     </Draggable>\n   *   );\n   * }\n   *\n   * This can be used for arbitrarily nested components, so long as the ref ends up\n   * pointing to the actual child DOM node and not a custom component.\n   */ nodeRef: _propTypes.default.object,\n    /**\n   * Called when dragging starts.\n   * If this function returns the boolean false, dragging will be canceled.\n   */ onStart: _propTypes.default.func,\n    /**\n   * Called while dragging.\n   * If this function returns the boolean false, dragging will be canceled.\n   */ onDrag: _propTypes.default.func,\n    /**\n   * Called when dragging stops.\n   * If this function returns the boolean false, the drag will remain active.\n   */ onStop: _propTypes.default.func,\n    /**\n   * A workaround option which can be passed if onMouseDown needs to be accessed,\n   * since it'll always be blocked (as there is internal use of onMouseDown)\n   */ onMouseDown: _propTypes.default.func,\n    /**\n   * `scale`, if set, applies scaling while dragging an element\n   */ scale: _propTypes.default.number,\n    /**\n   * These properties should be defined on the child, not here.\n   */ className: _shims.dontSetMe,\n    style: _shims.dontSetMe,\n    transform: _shims.dontSetMe\n});\n_defineProperty(DraggableCore, \"defaultProps\", {\n    allowAnyClick: false,\n    // by default only accept left click\n    disabled: false,\n    enableUserSelectHack: true,\n    onStart: function() {},\n    onDrag: function() {},\n    onStop: function() {},\n    onMouseDown: function() {},\n    scale: 1\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGVDb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsUUFBUUMsd0JBQXdCQyxtQkFBT0EsQ0FBQyx3R0FBTztBQUNuRCxJQUFJQyxhQUFhQyx1QkFBdUJGLG1CQUFPQSxDQUFDLDREQUFZO0FBQzVELElBQUlHLFlBQVlELHVCQUF1QkYsbUJBQU9BLENBQUMsZ0hBQVc7QUFDMUQsSUFBSUksVUFBVUosbUJBQU9BLENBQUMsc0ZBQWdCO0FBQ3RDLElBQUlLLGVBQWVMLG1CQUFPQSxDQUFDLGdHQUFxQjtBQUNoRCxJQUFJTSxTQUFTTixtQkFBT0EsQ0FBQyxvRkFBZTtBQUNwQyxJQUFJTyxPQUFPTCx1QkFBdUJGLG1CQUFPQSxDQUFDLGdGQUFhO0FBQ3ZELFNBQVNFLHVCQUF1Qk0sR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFWCxTQUFTVztJQUFJO0FBQUc7QUFDOUYsU0FBU0UseUJBQXlCQyxXQUFXO0lBQUksSUFBSSxPQUFPQyxZQUFZLFlBQVksT0FBTztJQUFNLElBQUlDLG9CQUFvQixJQUFJRDtJQUFXLElBQUlFLG1CQUFtQixJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVVDLFdBQVc7UUFBSSxPQUFPQSxjQUFjRyxtQkFBbUJEO0lBQW1CLEdBQUdGO0FBQWM7QUFDdFQsU0FBU1osd0JBQXdCUyxHQUFHLEVBQUVHLFdBQVc7SUFBSSxJQUFJLENBQUNBLGVBQWVILE9BQU9BLElBQUlDLFVBQVUsRUFBRTtRQUFFLE9BQU9EO0lBQUs7SUFBRSxJQUFJQSxRQUFRLFFBQVEsT0FBT0EsUUFBUSxZQUFZLE9BQU9BLFFBQVEsWUFBWTtRQUFFLE9BQU87WUFBRVgsU0FBU1c7UUFBSTtJQUFHO0lB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aEYsYUFBYXpELFdBQVdKLE9BQU8sQ0FBQzZJLElBQUk7SUFDcEM7O0dBRUMsR0FDREMsT0FBTzFJLFdBQVdKLE9BQU8sQ0FBQzBJLE1BQU07SUFDaEM7O0dBRUMsR0FDREssV0FBV3RJLE9BQU91SSxTQUFTO0lBQzNCQyxPQUFPeEksT0FBT3VJLFNBQVM7SUFDdkJFLFdBQVd6SSxPQUFPdUksU0FBUztBQUM3QjtBQUNBbEgsZ0JBQWdCd0IsZUFBZSxnQkFBZ0I7SUFDN0NRLGVBQWU7SUFDZixvQ0FBb0M7SUFDcENPLFVBQVU7SUFDVm9CLHNCQUFzQjtJQUN0QkgsU0FBUyxZQUFhO0lBQ3RCaUIsUUFBUSxZQUFhO0lBQ3JCUyxRQUFRLFlBQWE7SUFDckJuRCxhQUFhLFlBQWE7SUFDMUJpRixPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmFzb3JfY2xvbmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGVDb3JlLmpzP2VkZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xudmFyIF9kb21GbnMgPSByZXF1aXJlKFwiLi91dGlscy9kb21GbnNcIik7XG52YXIgX3Bvc2l0aW9uRm5zID0gcmVxdWlyZShcIi4vdXRpbHMvcG9zaXRpb25GbnNcIik7XG52YXIgX3NoaW1zID0gcmVxdWlyZShcIi4vdXRpbHMvc2hpbXNcIik7XG52YXIgX2xvZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvbG9nXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbi8qOjogaW1wb3J0IHR5cGUge0V2ZW50SGFuZGxlciwgTW91c2VUb3VjaEV2ZW50fSBmcm9tICcuL3V0aWxzL3R5cGVzJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7RWxlbWVudCBhcyBSZWFjdEVsZW1lbnR9IGZyb20gJ3JlYWN0JzsqL1xuLy8gU2ltcGxlIGFic3RyYWN0aW9uIGZvciBkcmFnZ2luZyBldmVudHMgbmFtZXMuXG5jb25zdCBldmVudHNGb3IgPSB7XG4gIHRvdWNoOiB7XG4gICAgc3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgICBtb3ZlOiAndG91Y2htb3ZlJyxcbiAgICBzdG9wOiAndG91Y2hlbmQnXG4gIH0sXG4gIG1vdXNlOiB7XG4gICAgc3RhcnQ6ICdtb3VzZWRvd24nLFxuICAgIG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIHN0b3A6ICdtb3VzZXVwJ1xuICB9XG59O1xuXG4vLyBEZWZhdWx0IHRvIG1vdXNlIGV2ZW50cy5cbmxldCBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7XG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZURhdGEgPSB7XG4gIG5vZGU6IEhUTUxFbGVtZW50LFxuICB4OiBudW1iZXIsIHk6IG51bWJlcixcbiAgZGVsdGFYOiBudW1iZXIsIGRlbHRhWTogbnVtYmVyLFxuICBsYXN0WDogbnVtYmVyLCBsYXN0WTogbnVtYmVyLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVFdmVudEhhbmRsZXIgPSAoZTogTW91c2VFdmVudCwgZGF0YTogRHJhZ2dhYmxlRGF0YSkgPT4gdm9pZCB8IGZhbHNlOyovXG4vKjo6IGV4cG9ydCB0eXBlIENvbnRyb2xQb3NpdGlvbiA9IHt4OiBudW1iZXIsIHk6IG51bWJlcn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24gPSB7eDogbnVtYmVyfHN0cmluZywgeTogbnVtYmVyfHN0cmluZ307Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wcyA9IHtcbiAgYWxsb3dBbnlDbGljazogYm9vbGVhbixcbiAgZGlzYWJsZWQ6IGJvb2xlYW4sXG4gIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiBib29sZWFuLFxuICBvblN0YXJ0OiBEcmFnZ2FibGVFdmVudEhhbmRsZXIsXG4gIG9uRHJhZzogRHJhZ2dhYmxlRXZlbnRIYW5kbGVyLFxuICBvblN0b3A6IERyYWdnYWJsZUV2ZW50SGFuZGxlcixcbiAgb25Nb3VzZURvd246IChlOiBNb3VzZUV2ZW50KSA9PiB2b2lkLFxuICBzY2FsZTogbnVtYmVyLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVDb3JlUHJvcHMgPSB7XG4gIC4uLkRyYWdnYWJsZUNvcmVEZWZhdWx0UHJvcHMsXG4gIGNhbmNlbDogc3RyaW5nLFxuICBjaGlsZHJlbjogUmVhY3RFbGVtZW50PGFueT4sXG4gIG9mZnNldFBhcmVudDogSFRNTEVsZW1lbnQsXG4gIGdyaWQ6IFtudW1iZXIsIG51bWJlcl0sXG4gIGhhbmRsZTogc3RyaW5nLFxuICBub2RlUmVmPzogP1JlYWN0LkVsZW1lbnRSZWY8YW55Pixcbn07Ki9cbi8vXG4vLyBEZWZpbmUgPERyYWdnYWJsZUNvcmU+LlxuLy9cbi8vIDxEcmFnZ2FibGVDb3JlPiBpcyBmb3IgYWR2YW5jZWQgdXNhZ2Ugb2YgPERyYWdnYWJsZT4uIEl0IG1haW50YWlucyBtaW5pbWFsIGludGVybmFsIHN0YXRlIHNvIGl0IGNhblxuLy8gd29yayB3ZWxsIHdpdGggbGlicmFyaWVzIHRoYXQgcmVxdWlyZSBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgZWxlbWVudC5cbi8vXG5cbmNsYXNzIERyYWdnYWJsZUNvcmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgLyo6OiA8RHJhZ2dhYmxlQ29yZVByb3BzPiove1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYWdnaW5nXCIsIGZhbHNlKTtcbiAgICAvLyBVc2VkIHdoaWxlIGRyYWdnaW5nIHRvIGRldGVybWluZSBkZWx0YXMuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGFzdFhcIiwgTmFOKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXN0WVwiLCBOYU4pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvdWNoSWRlbnRpZmllclwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb3VudGVkXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVEcmFnU3RhcnRcIiwgZSA9PiB7XG4gICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGF0dGFjaCBldmVudCBoYW5kbGVycyBvbiB0b3Agb2YgdGhpcyBvbmUuXG4gICAgICB0aGlzLnByb3BzLm9uTW91c2VEb3duKGUpO1xuXG4gICAgICAvLyBPbmx5IGFjY2VwdCBsZWZ0LWNsaWNrcy5cbiAgICAgIGlmICghdGhpcy5wcm9wcy5hbGxvd0FueUNsaWNrICYmIHR5cGVvZiBlLmJ1dHRvbiA9PT0gJ251bWJlcicgJiYgZS5idXR0b24gIT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gR2V0IG5vZGVzLiBCZSBzdXJlIHRvIGdyYWIgcmVsYXRpdmUgZG9jdW1lbnQgKGNvdWxkIGJlIGlmcmFtZWQpXG4gICAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICAgIGlmICghdGhpc05vZGUgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxEcmFnZ2FibGVDb3JlPiBub3QgbW91bnRlZCBvbiBEcmFnU3RhcnQhJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG93bmVyRG9jdW1lbnRcbiAgICAgIH0gPSB0aGlzTm9kZTtcblxuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBpZiBoYW5kbGUgb3IgY2FuY2VsIHByb3Agd2FzIHByb3ZpZGVkIGFuZCBzZWxlY3RvciBkb2Vzbid0IG1hdGNoLlxuICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQgfHwgIShlLnRhcmdldCBpbnN0YW5jZW9mIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuTm9kZSkgfHwgdGhpcy5wcm9wcy5oYW5kbGUgJiYgISgwLCBfZG9tRm5zLm1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbykoZS50YXJnZXQsIHRoaXMucHJvcHMuaGFuZGxlLCB0aGlzTm9kZSkgfHwgdGhpcy5wcm9wcy5jYW5jZWwgJiYgKDAsIF9kb21GbnMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKShlLnRhcmdldCwgdGhpcy5wcm9wcy5jYW5jZWwsIHRoaXNOb2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIG1vYmlsZSBkZXZpY2VzLCBsaWtlIGlwYWQvaXBob25lLlxuICAgICAgLy8gSW1wb3J0YW50IHRoYXQgdGhpcyBpcyBhZnRlciBoYW5kbGUvY2FuY2VsLlxuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIFNldCB0b3VjaCBpZGVudGlmaWVyIGluIGNvbXBvbmVudCBzdGF0ZSBpZiB0aGlzIGlzIGEgdG91Y2ggZXZlbnQuIFRoaXMgYWxsb3dzIHVzIHRvXG4gICAgICAvLyBkaXN0aW5ndWlzaCBiZXR3ZWVuIGluZGl2aWR1YWwgdG91Y2hlcyBvbiBtdWx0aXRvdWNoIHNjcmVlbnMgYnkgaWRlbnRpZnlpbmcgd2hpY2hcbiAgICAgIC8vIHRvdWNocG9pbnQgd2FzIHNldCB0byB0aGlzIGVsZW1lbnQuXG4gICAgICBjb25zdCB0b3VjaElkZW50aWZpZXIgPSAoMCwgX2RvbUZucy5nZXRUb3VjaElkZW50aWZpZXIpKGUpO1xuICAgICAgdGhpcy50b3VjaElkZW50aWZpZXIgPSB0b3VjaElkZW50aWZpZXI7XG5cbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBkcmFnIHBvaW50IGZyb20gdGhlIGV2ZW50LiBUaGlzIGlzIHVzZWQgYXMgdGhlIG9mZnNldC5cbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIHRvdWNoSWRlbnRpZmllciwgdGhpcyk7XG4gICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuOyAvLyBub3QgcG9zc2libGUgYnV0IHNhdGlzZmllcyBmbG93XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBwb3NpdGlvbjtcblxuICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IG9iamVjdCB3aXRoIGFsbCB0aGUgZGF0YSBwYXJlbnRzIG5lZWQgdG8gbWFrZSBhIGRlY2lzaW9uIGhlcmUuXG4gICAgICBjb25zdCBjb3JlRXZlbnQgPSAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZUNvcmVEYXRhKSh0aGlzLCB4LCB5KTtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGVDb3JlOiBoYW5kbGVEcmFnU3RhcnQ6ICVqJywgY29yZUV2ZW50KTtcblxuICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyLiBJZiBpdCByZXR1cm5zIGV4cGxpY2l0IGZhbHNlLCBjYW5jZWwuXG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnY2FsbGluZycsIHRoaXMucHJvcHMub25TdGFydCk7XG4gICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSB0aGlzLnByb3BzLm9uU3RhcnQoZSwgY29yZUV2ZW50KTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IGZhbHNlIHx8IHRoaXMubW91bnRlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgLy8gQWRkIGEgc3R5bGUgdG8gdGhlIGJvZHkgdG8gZGlzYWJsZSB1c2VyLXNlbGVjdC4gVGhpcyBwcmV2ZW50cyB0ZXh0IGZyb21cbiAgICAgIC8vIGJlaW5nIHNlbGVjdGVkIGFsbCBvdmVyIHRoZSBwYWdlLlxuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLmFkZFVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQpO1xuXG4gICAgICAvLyBJbml0aWF0ZSBkcmFnZ2luZy4gU2V0IHRoZSBjdXJyZW50IHggYW5kIHkgYXMgb2Zmc2V0c1xuICAgICAgLy8gc28gd2Uga25vdyBob3cgbXVjaCB3ZSd2ZSBtb3ZlZCBkdXJpbmcgdGhlIGRyYWcuIFRoaXMgYWxsb3dzIHVzXG4gICAgICAvLyB0byBkcmFnIGVsZW1lbnRzIGFyb3VuZCBldmVuIGlmIHRoZXkgaGF2ZSBiZWVuIG1vdmVkLCB3aXRob3V0IGlzc3VlLlxuICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLmxhc3RYID0geDtcbiAgICAgIHRoaXMubGFzdFkgPSB5O1xuXG4gICAgICAvLyBBZGQgZXZlbnRzIHRvIHRoZSBkb2N1bWVudCBkaXJlY3RseSBzbyB3ZSBjYXRjaCB3aGVuIHRoZSB1c2VyJ3MgbW91c2UvdG91Y2ggbW92ZXMgb3V0c2lkZSBvZlxuICAgICAgLy8gdGhpcyBlbGVtZW50LiBXZSB1c2UgZGlmZmVyZW50IGV2ZW50cyBkZXBlbmRpbmcgb24gd2hldGhlciBvciBub3Qgd2UgaGF2ZSBkZXRlY3RlZCB0aGF0IHRoaXNcbiAgICAgIC8vIGlzIGEgdG91Y2gtY2FwYWJsZSBkZXZpY2UuXG4gICAgICAoMCwgX2RvbUZucy5hZGRFdmVudCkob3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLm1vdmUsIHRoaXMuaGFuZGxlRHJhZyk7XG4gICAgICAoMCwgX2RvbUZucy5hZGRFdmVudCkob3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYWdcIiwgZSA9PiB7XG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgZHJhZyBwb2ludCBmcm9tIHRoZSBldmVudC4gVGhpcyBpcyB1c2VkIGFzIHRoZSBvZmZzZXQuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9ICgwLCBfcG9zaXRpb25GbnMuZ2V0Q29udHJvbFBvc2l0aW9uKShlLCB0aGlzLnRvdWNoSWRlbnRpZmllciwgdGhpcyk7XG4gICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgbGV0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHBvc2l0aW9uO1xuXG4gICAgICAvLyBTbmFwIHRvIGdyaWQgaWYgcHJvcCBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy5ncmlkKSkge1xuICAgICAgICBsZXQgZGVsdGFYID0geCAtIHRoaXMubGFzdFgsXG4gICAgICAgICAgZGVsdGFZID0geSAtIHRoaXMubGFzdFk7XG4gICAgICAgIFtkZWx0YVgsIGRlbHRhWV0gPSAoMCwgX3Bvc2l0aW9uRm5zLnNuYXBUb0dyaWQpKHRoaXMucHJvcHMuZ3JpZCwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICBpZiAoIWRlbHRhWCAmJiAhZGVsdGFZKSByZXR1cm47IC8vIHNraXAgdXNlbGVzcyBkcmFnXG4gICAgICAgIHggPSB0aGlzLmxhc3RYICsgZGVsdGFYLCB5ID0gdGhpcy5sYXN0WSArIGRlbHRhWTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKHRoaXMsIHgsIHkpO1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWc6ICVqJywgY29yZUV2ZW50KTtcblxuICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyLiBJZiBpdCByZXR1cm5zIGV4cGxpY2l0IGZhbHNlLCB0cmlnZ2VyIGVuZC5cbiAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9IHRoaXMucHJvcHMub25EcmFnKGUsIGNvcmVFdmVudCk7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSB8fCB0aGlzLm1vdW50ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gJEZsb3dJZ25vcmVcbiAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdG9wKG5ldyBNb3VzZUV2ZW50KCdtb3VzZXVwJykpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBPbGQgYnJvd3NlcnNcbiAgICAgICAgICBjb25zdCBldmVudCA9ICgoZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJykgLyo6IGFueSovKSAvKjogTW91c2VUb3VjaEV2ZW50Ki8pO1xuICAgICAgICAgIC8vIEkgc2VlIHdoeSB0aGlzIGluc2FuaXR5IHdhcyBkZXByZWNhdGVkXG4gICAgICAgICAgLy8gJEZsb3dJZ25vcmVcbiAgICAgICAgICBldmVudC5pbml0TW91c2VFdmVudCgnbW91c2V1cCcsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0b3AoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFggPSB4O1xuICAgICAgdGhpcy5sYXN0WSA9IHk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhZ1N0b3BcIiwgZSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHJldHVybjtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIHRoaXMudG91Y2hJZGVudGlmaWVyLCB0aGlzKTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSByZXR1cm47XG4gICAgICBsZXQge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gcG9zaXRpb247XG5cbiAgICAgIC8vIFNuYXAgdG8gZ3JpZCBpZiBwcm9wIGhhcyBiZWVuIHByb3ZpZGVkXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnByb3BzLmdyaWQpKSB7XG4gICAgICAgIGxldCBkZWx0YVggPSB4IC0gdGhpcy5sYXN0WCB8fCAwO1xuICAgICAgICBsZXQgZGVsdGFZID0geSAtIHRoaXMubGFzdFkgfHwgMDtcbiAgICAgICAgW2RlbHRhWCwgZGVsdGFZXSA9ICgwLCBfcG9zaXRpb25GbnMuc25hcFRvR3JpZCkodGhpcy5wcm9wcy5ncmlkLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHggPSB0aGlzLmxhc3RYICsgZGVsdGFYLCB5ID0gdGhpcy5sYXN0WSArIGRlbHRhWTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKHRoaXMsIHgsIHkpO1xuXG4gICAgICAvLyBDYWxsIGV2ZW50IGhhbmRsZXJcbiAgICAgIGNvbnN0IHNob3VsZENvbnRpbnVlID0gdGhpcy5wcm9wcy5vblN0b3AoZSwgY29yZUV2ZW50KTtcbiAgICAgIGlmIChzaG91bGRDb250aW51ZSA9PT0gZmFsc2UgfHwgdGhpcy5tb3VudGVkID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgdGhpc05vZGUgPSB0aGlzLmZpbmRET01Ob2RlKCk7XG4gICAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHVzZXItc2VsZWN0IGhhY2tcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWdTdG9wOiAlaicsIGNvcmVFdmVudCk7XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBlbC5cbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdFggPSBOYU47XG4gICAgICB0aGlzLmxhc3RZID0gTmFOO1xuICAgICAgaWYgKHRoaXNOb2RlKSB7XG4gICAgICAgIC8vIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuICAgICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlQ29yZTogUmVtb3ZpbmcgaGFuZGxlcnMnKTtcbiAgICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkodGhpc05vZGUub3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uTW91c2VEb3duXCIsIGUgPT4ge1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLm1vdXNlOyAvLyBvbiB0b3VjaHNjcmVlbiBsYXB0b3BzIHdlIGNvdWxkIHN3aXRjaCBiYWNrIHRvIG1vdXNlXG5cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZURyYWdTdGFydChlKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbk1vdXNlVXBcIiwgZSA9PiB7XG4gICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVEcmFnU3RvcChlKTtcbiAgICB9KTtcbiAgICAvLyBTYW1lIGFzIG9uTW91c2VEb3duIChzdGFydCBkcmFnKSwgYnV0IG5vdyBjb25zaWRlciB0aGlzIGEgdG91Y2ggZGV2aWNlLlxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVG91Y2hTdGFydFwiLCBlID0+IHtcbiAgICAgIC8vIFdlJ3JlIG9uIGEgdG91Y2ggZGV2aWNlIG5vdywgc28gY2hhbmdlIHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLnRvdWNoO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KGUpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVG91Y2hFbmRcIiwgZSA9PiB7XG4gICAgICAvLyBXZSdyZSBvbiBhIHRvdWNoIGRldmljZSBub3csIHNvIGNoYW5nZSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci50b3VjaDtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZURyYWdTdG9wKGUpO1xuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgLy8gVG91Y2ggaGFuZGxlcnMgbXVzdCBiZSBhZGRlZCB3aXRoIHtwYXNzaXZlOiBmYWxzZX0gdG8gYmUgY2FuY2VsYWJsZS5cbiAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzAxL3Njcm9sbGluZy1pbnRlcnZlbnRpb25cbiAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgICgwLCBfZG9tRm5zLmFkZEV2ZW50KSh0aGlzTm9kZSwgZXZlbnRzRm9yLnRvdWNoLnN0YXJ0LCB0aGlzLm9uVG91Y2hTdGFydCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgIC8vIFJlbW92ZSBhbnkgbGVmdG92ZXIgZXZlbnQgaGFuZGxlcnMuIFJlbW92ZSBib3RoIHRvdWNoIGFuZCBtb3VzZSBoYW5kbGVycyBpbiBjYXNlXG4gICAgLy8gc29tZSBicm93c2VyIHF1aXJrIGNhdXNlZCBhIHRvdWNoIGV2ZW50IHRvIGZpcmUgZHVyaW5nIGEgbW91c2UgbW92ZSwgb3IgdmljZSB2ZXJzYS5cbiAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3duZXJEb2N1bWVudFxuICAgICAgfSA9IHRoaXNOb2RlO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci50b3VjaC5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5zdG9wLCB0aGlzLmhhbmRsZURyYWdTdG9wKTtcbiAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IudG91Y2guc3RvcCwgdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG4gICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkodGhpc05vZGUsIGV2ZW50c0Zvci50b3VjaC5zdGFydCwgdGhpcy5vblRvdWNoU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWN0IFN0cmljdCBNb2RlIGNvbXBhdGliaWxpdHk6IGlmIGBub2RlUmVmYCBpcyBwYXNzZWQsIHdlIHdpbGwgdXNlIGl0IGluc3RlYWQgb2YgdHJ5aW5nIHRvIGZpbmRcbiAgLy8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUgb3Vyc2VsdmVzLiBTZWUgdGhlIFJFQURNRSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgZmluZERPTU5vZGUoKSAvKjogP0hUTUxFbGVtZW50Ki97XG4gICAgdmFyIF90aGlzJHByb3BzLCBfdGhpcyRwcm9wczI7XG4gICAgcmV0dXJuIChfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMpICE9PSBudWxsICYmIF90aGlzJHByb3BzICE9PSB2b2lkIDAgJiYgX3RoaXMkcHJvcHMubm9kZVJlZiA/IChfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wczIgPT09IHZvaWQgMCB8fCAoX3RoaXMkcHJvcHMyID0gX3RoaXMkcHJvcHMyLm5vZGVSZWYpID09PSBudWxsIHx8IF90aGlzJHByb3BzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMyLmN1cnJlbnQgOiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxuICByZW5kZXIoKSAvKjogUmVhY3QuRWxlbWVudDxhbnk+Ki97XG4gICAgLy8gUmV1c2UgdGhlIGNoaWxkIHByb3ZpZGVkXG4gICAgLy8gVGhpcyBtYWtlcyBpdCBmbGV4aWJsZSB0byB1c2Ugd2hhdGV2ZXIgZWxlbWVudCBpcyB3YW50ZWQgKGRpdiwgdWwsIGV0YylcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB7XG4gICAgICAvLyBOb3RlOiBtb3VzZU1vdmUgaGFuZGxlciBpcyBhdHRhY2hlZCB0byBkb2N1bWVudCBzbyBpdCB3aWxsIHN0aWxsIGZ1bmN0aW9uXG4gICAgICAvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHF1aWNrbHkgYW5kIGxlYXZlcyB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50LlxuICAgICAgb25Nb3VzZURvd246IHRoaXMub25Nb3VzZURvd24sXG4gICAgICBvbk1vdXNlVXA6IHRoaXMub25Nb3VzZVVwLFxuICAgICAgLy8gb25Ub3VjaFN0YXJ0IGlzIGFkZGVkIG9uIGBjb21wb25lbnREaWRNb3VudGAgc28gdGhleSBjYW4gYmUgYWRkZWQgd2l0aFxuICAgICAgLy8ge3Bhc3NpdmU6IGZhbHNlfSwgd2hpY2ggYWxsb3dzIGl0IHRvIGNhbmNlbC4gU2VlXG4gICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzAxL3Njcm9sbGluZy1pbnRlcnZlbnRpb25cbiAgICAgIG9uVG91Y2hFbmQ6IHRoaXMub25Ub3VjaEVuZFxuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGVDb3JlO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZUNvcmUsIFwiZGlzcGxheU5hbWVcIiwgJ0RyYWdnYWJsZUNvcmUnKTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGVDb3JlLCBcInByb3BUeXBlc1wiLCB7XG4gIC8qKlxuICAgKiBgYWxsb3dBbnlDbGlja2AgYWxsb3dzIGRyYWdnaW5nIHVzaW5nIGFueSBtb3VzZSBidXR0b24uXG4gICAqIEJ5IGRlZmF1bHQsIHdlIG9ubHkgYWNjZXB0IHRoZSBsZWZ0IGJ1dHRvbi5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGFsbG93QW55Q2xpY2s6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIGBkaXNhYmxlZGAsIGlmIHRydWUsIHN0b3BzIHRoZSA8RHJhZ2dhYmxlPiBmcm9tIGRyYWdnaW5nLiBBbGwgaGFuZGxlcnMsXG4gICAqIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgb25Nb3VzZURvd25gLCB3aWxsIG5vdCBmaXJlLlxuICAgKi9cbiAgZGlzYWJsZWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvKipcbiAgICogQnkgZGVmYXVsdCwgd2UgYWRkICd1c2VyLXNlbGVjdDpub25lJyBhdHRyaWJ1dGVzIHRvIHRoZSBkb2N1bWVudCBib2R5XG4gICAqIHRvIHByZXZlbnQgdWdseSB0ZXh0IHNlbGVjdGlvbiBkdXJpbmcgZHJhZy4gSWYgdGhpcyBpcyBjYXVzaW5nIHByb2JsZW1zXG4gICAqIGZvciB5b3VyIGFwcCwgc2V0IHRoaXMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLyoqXG4gICAqIGBvZmZzZXRQYXJlbnRgLCBpZiBzZXQsIHVzZXMgdGhlIHBhc3NlZCBET00gbm9kZSB0byBjb21wdXRlIGRyYWcgb2Zmc2V0c1xuICAgKiBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBwYXJlbnQgbm9kZS5cbiAgICovXG4gIG9mZnNldFBhcmVudDogZnVuY3Rpb24gKHByb3BzIC8qOiBEcmFnZ2FibGVDb3JlUHJvcHMqLywgcHJvcE5hbWUgLyo6ICRLZXlzPERyYWdnYWJsZUNvcmVQcm9wcz4qLykge1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gJiYgcHJvcHNbcHJvcE5hbWVdLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdnYWJsZVxcJ3Mgb2Zmc2V0UGFyZW50IG11c3QgYmUgYSBET00gTm9kZS4nKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBgZ3JpZGAgc3BlY2lmaWVzIHRoZSB4IGFuZCB5IHRoYXQgZHJhZ2dpbmcgc2hvdWxkIHNuYXAgdG8uXG4gICAqL1xuICBncmlkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcbiAgLyoqXG4gICAqIGBoYW5kbGVgIHNwZWNpZmllcyBhIHNlbGVjdG9yIHRvIGJlIHVzZWQgYXMgdGhlIGhhbmRsZSB0aGF0IGluaXRpYXRlcyBkcmFnLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgIDxEcmFnZ2FibGUgaGFuZGxlPVwiLmhhbmRsZVwiPlxuICAgKiAgICAgICAgICAgICAgPGRpdj5cbiAgICogICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhhbmRsZVwiPkNsaWNrIG1lIHRvIGRyYWc8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICA8ZGl2PlRoaXMgaXMgc29tZSBvdGhlciBjb250ZW50PC9kaXY+XG4gICAqICAgICAgICAgICAgICA8L2Rpdj5cbiAgICogICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBoYW5kbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8qKlxuICAgKiBgY2FuY2VsYCBzcGVjaWZpZXMgYSBzZWxlY3RvciB0byBiZSB1c2VkIHRvIHByZXZlbnQgZHJhZyBpbml0aWFsaXphdGlvbi5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgICByZXR1cm4oXG4gICAqICAgICAgICAgICAgICAgPERyYWdnYWJsZSBjYW5jZWw9XCIuY2FuY2VsXCI+XG4gICAqICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYW5jZWxcIj5Zb3UgY2FuJ3QgZHJhZyBmcm9tIGhlcmU8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICAgICA8ZGl2PkRyYWdnaW5nIGhlcmUgd29ya3MgZmluZTwvZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICogICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICogICAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBjYW5jZWw6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8qIElmIHJ1bm5pbmcgaW4gUmVhY3QgU3RyaWN0IG1vZGUsIFJlYWN0RE9NLmZpbmRET01Ob2RlKCkgaXMgZGVwcmVjYXRlZC5cbiAgICogVW5mb3J0dW5hdGVseSwgaW4gb3JkZXIgZm9yIDxEcmFnZ2FibGU+IHRvIHdvcmsgcHJvcGVybHksIHdlIG5lZWQgcmF3IGFjY2Vzc1xuICAgKiB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZS4gSWYgeW91IHdhbnQgdG8gYXZvaWQgdGhlIHdhcm5pbmcsIHBhc3MgYSBgbm9kZVJlZmBcbiAgICogYXMgaW4gdGhpcyBleGFtcGxlOlxuICAgKlxuICAgKiBmdW5jdGlvbiBNeUNvbXBvbmVudCgpIHtcbiAgICogICBjb25zdCBub2RlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgKiAgIHJldHVybiAoXG4gICAqICAgICA8RHJhZ2dhYmxlIG5vZGVSZWY9e25vZGVSZWZ9PlxuICAgKiAgICAgICA8ZGl2IHJlZj17bm9kZVJlZn0+RXhhbXBsZSBUYXJnZXQ8L2Rpdj5cbiAgICogICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICk7XG4gICAqIH1cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCBmb3IgYXJiaXRyYXJpbHkgbmVzdGVkIGNvbXBvbmVudHMsIHNvIGxvbmcgYXMgdGhlIHJlZiBlbmRzIHVwXG4gICAqIHBvaW50aW5nIHRvIHRoZSBhY3R1YWwgY2hpbGQgRE9NIG5vZGUgYW5kIG5vdCBhIGN1c3RvbSBjb21wb25lbnQuXG4gICAqL1xuICBub2RlUmVmOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LFxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzLlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIGRyYWdnaW5nIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAqL1xuICBvblN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxlZCB3aGlsZSBkcmFnZ2luZy5cbiAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBib29sZWFuIGZhbHNlLCBkcmFnZ2luZyB3aWxsIGJlIGNhbmNlbGVkLlxuICAgKi9cbiAgb25EcmFnOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGRyYWdnaW5nIHN0b3BzLlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIHRoZSBkcmFnIHdpbGwgcmVtYWluIGFjdGl2ZS5cbiAgICovXG4gIG9uU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8qKlxuICAgKiBBIHdvcmthcm91bmQgb3B0aW9uIHdoaWNoIGNhbiBiZSBwYXNzZWQgaWYgb25Nb3VzZURvd24gbmVlZHMgdG8gYmUgYWNjZXNzZWQsXG4gICAqIHNpbmNlIGl0J2xsIGFsd2F5cyBiZSBibG9ja2VkIChhcyB0aGVyZSBpcyBpbnRlcm5hbCB1c2Ugb2Ygb25Nb3VzZURvd24pXG4gICAqL1xuICBvbk1vdXNlRG93bjogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8qKlxuICAgKiBgc2NhbGVgLCBpZiBzZXQsIGFwcGxpZXMgc2NhbGluZyB3aGlsZSBkcmFnZ2luZyBhbiBlbGVtZW50XG4gICAqL1xuICBzY2FsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgLyoqXG4gICAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIGJlIGRlZmluZWQgb24gdGhlIGNoaWxkLCBub3QgaGVyZS5cbiAgICovXG4gIGNsYXNzTmFtZTogX3NoaW1zLmRvbnRTZXRNZSxcbiAgc3R5bGU6IF9zaGltcy5kb250U2V0TWUsXG4gIHRyYW5zZm9ybTogX3NoaW1zLmRvbnRTZXRNZVxufSk7XG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlQ29yZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBhbGxvd0FueUNsaWNrOiBmYWxzZSxcbiAgLy8gYnkgZGVmYXVsdCBvbmx5IGFjY2VwdCBsZWZ0IGNsaWNrXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgZW5hYmxlVXNlclNlbGVjdEhhY2s6IHRydWUsXG4gIG9uU3RhcnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBvbkRyYWc6IGZ1bmN0aW9uICgpIHt9LFxuICBvblN0b3A6IGZ1bmN0aW9uICgpIHt9LFxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge30sXG4gIHNjYWxlOiAxXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiUmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfcHJvcFR5cGVzIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9yZWFjdERvbSIsIl9kb21GbnMiLCJfcG9zaXRpb25GbnMiLCJfc2hpbXMiLCJfbG9nIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsIm5vZGVJbnRlcm9wIiwiV2Vha01hcCIsImNhY2hlQmFiZWxJbnRlcm9wIiwiY2FjaGVOb2RlSW50ZXJvcCIsImNhY2hlIiwiaGFzIiwiZ2V0IiwibmV3T2JqIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsInNldCIsIl9kZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiYXJnIiwiX3RvUHJpbWl0aXZlIiwiU3RyaW5nIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwidW5kZWZpbmVkIiwicmVzIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiZXZlbnRzRm9yIiwidG91Y2giLCJzdGFydCIsIm1vdmUiLCJzdG9wIiwibW91c2UiLCJkcmFnRXZlbnRGb3IiLCJEcmFnZ2FibGVDb3JlIiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJhcmd1bWVudHMiLCJOYU4iLCJlIiwicHJvcHMiLCJvbk1vdXNlRG93biIsImFsbG93QW55Q2xpY2siLCJidXR0b24iLCJ0aGlzTm9kZSIsImZpbmRET01Ob2RlIiwib3duZXJEb2N1bWVudCIsImJvZHkiLCJFcnJvciIsImRpc2FibGVkIiwidGFyZ2V0IiwiZGVmYXVsdFZpZXciLCJOb2RlIiwiaGFuZGxlIiwibWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvIiwiY2FuY2VsIiwidHlwZSIsInByZXZlbnREZWZhdWx0IiwidG91Y2hJZGVudGlmaWVyIiwiZ2V0VG91Y2hJZGVudGlmaWVyIiwicG9zaXRpb24iLCJnZXRDb250cm9sUG9zaXRpb24iLCJ4IiwieSIsImNvcmVFdmVudCIsImNyZWF0ZUNvcmVEYXRhIiwib25TdGFydCIsInNob3VsZFVwZGF0ZSIsIm1vdW50ZWQiLCJlbmFibGVVc2VyU2VsZWN0SGFjayIsImFkZFVzZXJTZWxlY3RTdHlsZXMiLCJkcmFnZ2luZyIsImxhc3RYIiwibGFzdFkiLCJhZGRFdmVudCIsImhhbmRsZURyYWciLCJoYW5kbGVEcmFnU3RvcCIsIkFycmF5IiwiaXNBcnJheSIsImdyaWQiLCJkZWx0YVgiLCJkZWx0YVkiLCJzbmFwVG9HcmlkIiwib25EcmFnIiwiTW91c2VFdmVudCIsImVyciIsImV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRNb3VzZUV2ZW50Iiwid2luZG93Iiwic2hvdWxkQ29udGludWUiLCJvblN0b3AiLCJyZW1vdmVVc2VyU2VsZWN0U3R5bGVzIiwicmVtb3ZlRXZlbnQiLCJoYW5kbGVEcmFnU3RhcnQiLCJjb21wb25lbnREaWRNb3VudCIsIm9uVG91Y2hTdGFydCIsInBhc3NpdmUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIl90aGlzJHByb3BzIiwiX3RoaXMkcHJvcHMyIiwibm9kZVJlZiIsImN1cnJlbnQiLCJyZW5kZXIiLCJjbG9uZUVsZW1lbnQiLCJDaGlsZHJlbiIsIm9ubHkiLCJjaGlsZHJlbiIsIm9uTW91c2VVcCIsIm9uVG91Y2hFbmQiLCJib29sIiwibm9kZSIsImlzUmVxdWlyZWQiLCJvZmZzZXRQYXJlbnQiLCJwcm9wTmFtZSIsIm5vZGVUeXBlIiwiYXJyYXlPZiIsIm51bWJlciIsInN0cmluZyIsIm9iamVjdCIsImZ1bmMiLCJzY2FsZSIsImNsYXNzTmFtZSIsImRvbnRTZXRNZSIsInN0eWxlIiwidHJhbnNmb3JtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/DraggableCore.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/cjs.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { default: Draggable, DraggableCore } = __webpack_require__(/*! ./Draggable */ \"(ssr)/./node_modules/react-draggable/build/cjs/Draggable.js\");\n// Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.\n// See https://github.com/mzabriskie/react-draggable/pull/254\n// and https://github.com/mzabriskie/react-draggable/issues/266\nmodule.exports = Draggable;\nmodule.exports[\"default\"] = Draggable;\nmodule.exports.DraggableCore = DraggableCore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixNQUFNLEVBQ0pBLFNBQVNDLFNBQVMsRUFDbEJDLGFBQWEsRUFDZCxHQUFHQyxtQkFBT0EsQ0FBQztBQUVaLHlKQUF5SjtBQUN6Siw2REFBNkQ7QUFDN0QsK0RBQStEO0FBQy9EQyxPQUFPQyxPQUFPLEdBQUdKO0FBQ2pCRyx5QkFBc0IsR0FBR0g7QUFDekJHLDRCQUE0QixHQUFHRiIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYXNvcl9jbG9uZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL2Nqcy5qcz83NzYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB7XG4gIGRlZmF1bHQ6IERyYWdnYWJsZSxcbiAgRHJhZ2dhYmxlQ29yZVxufSA9IHJlcXVpcmUoJy4vRHJhZ2dhYmxlJyk7XG5cbi8vIFByZXZpb3VzIHZlcnNpb25zIG9mIHRoaXMgbGliIGV4cG9ydGVkIDxEcmFnZ2FibGU+IGFzIHRoZSByb290IGV4cG9ydC4gQXMgdG8gbm8tLy8gdGhlbSwgb3IgVHlwZVNjcmlwdCwgd2UgZXhwb3J0ICpib3RoKiBhcyB0aGUgcm9vdCBhbmQgYXMgJ2RlZmF1bHQnLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL3JlYWN0LWRyYWdnYWJsZS9wdWxsLzI1NFxuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL3JlYWN0LWRyYWdnYWJsZS9pc3N1ZXMvMjY2XG5tb2R1bGUuZXhwb3J0cyA9IERyYWdnYWJsZTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGU7XG5tb2R1bGUuZXhwb3J0cy5EcmFnZ2FibGVDb3JlID0gRHJhZ2dhYmxlQ29yZTsiXSwibmFtZXMiOlsiZGVmYXVsdCIsIkRyYWdnYWJsZSIsIkRyYWdnYWJsZUNvcmUiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/utils/domFns.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/domFns.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addClassName = addClassName;\nexports.addEvent = addEvent;\nexports.addUserSelectStyles = addUserSelectStyles;\nexports.createCSSTransform = createCSSTransform;\nexports.createSVGTransform = createSVGTransform;\nexports.getTouch = getTouch;\nexports.getTouchIdentifier = getTouchIdentifier;\nexports.getTranslation = getTranslation;\nexports.innerHeight = innerHeight;\nexports.innerWidth = innerWidth;\nexports.matchesSelector = matchesSelector;\nexports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;\nexports.offsetXYFromParent = offsetXYFromParent;\nexports.outerHeight = outerHeight;\nexports.outerWidth = outerWidth;\nexports.removeClassName = removeClassName;\nexports.removeEvent = removeEvent;\nexports.removeUserSelectStyles = removeUserSelectStyles;\nvar _shims = __webpack_require__(/*! ./shims */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _getPrefix = _interopRequireWildcard(__webpack_require__(/*! ./getPrefix */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/getPrefix.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\n/*:: import type {ControlPosition, PositionOffsetControlPosition, MouseTouchEvent} from './types';*/ let matchesSelectorFunc = \"\";\nfunction matchesSelector(el /*: Node*/ , selector /*: string*/ ) /*: boolean*/ {\n    if (!matchesSelectorFunc) {\n        matchesSelectorFunc = (0, _shims.findInArray)([\n            \"matches\",\n            \"webkitMatchesSelector\",\n            \"mozMatchesSelector\",\n            \"msMatchesSelector\",\n            \"oMatchesSelector\"\n        ], function(method) {\n            // $FlowIgnore: Doesn't think elements are indexable\n            return (0, _shims.isFunction)(el[method]);\n        });\n    }\n    // Might not be found entirely (not an Element?) - in that case, bail\n    // $FlowIgnore: Doesn't think elements are indexable\n    if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;\n    // $FlowIgnore: Doesn't think elements are indexable\n    return el[matchesSelectorFunc](selector);\n}\n// Works up the tree to the draggable itself attempting to match selector.\nfunction matchesSelectorAndParentsTo(el /*: Node*/ , selector /*: string*/ , baseNode /*: Node*/ ) /*: boolean*/ {\n    let node = el;\n    do {\n        if (matchesSelector(node, selector)) return true;\n        if (node === baseNode) return false;\n        // $FlowIgnore[incompatible-type]\n        node = node.parentNode;\n    }while (node);\n    return false;\n}\nfunction addEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {\n    if (!el) return;\n    const options = {\n        capture: true,\n        ...inputOptions\n    };\n    // $FlowIgnore[method-unbinding]\n    if (el.addEventListener) {\n        el.addEventListener(event, handler, options);\n    } else if (el.attachEvent) {\n        el.attachEvent(\"on\" + event, handler);\n    } else {\n        // $FlowIgnore: Doesn't think elements are indexable\n        el[\"on\" + event] = handler;\n    }\n}\nfunction removeEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {\n    if (!el) return;\n    const options = {\n        capture: true,\n        ...inputOptions\n    };\n    // $FlowIgnore[method-unbinding]\n    if (el.removeEventListener) {\n        el.removeEventListener(event, handler, options);\n    } else if (el.detachEvent) {\n        el.detachEvent(\"on\" + event, handler);\n    } else {\n        // $FlowIgnore: Doesn't think elements are indexable\n        el[\"on\" + event] = null;\n    }\n}\nfunction outerHeight(node /*: HTMLElement*/ ) /*: number*/ {\n    // This is deliberately excluding margin for our calculations, since we are using\n    // offsetTop which is including margin. See getBoundPosition\n    let height = node.clientHeight;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    height += (0, _shims.int)(computedStyle.borderTopWidth);\n    height += (0, _shims.int)(computedStyle.borderBottomWidth);\n    return height;\n}\nfunction outerWidth(node /*: HTMLElement*/ ) /*: number*/ {\n    // This is deliberately excluding margin for our calculations, since we are using\n    // offsetLeft which is including margin. See getBoundPosition\n    let width = node.clientWidth;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    width += (0, _shims.int)(computedStyle.borderLeftWidth);\n    width += (0, _shims.int)(computedStyle.borderRightWidth);\n    return width;\n}\nfunction innerHeight(node /*: HTMLElement*/ ) /*: number*/ {\n    let height = node.clientHeight;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    height -= (0, _shims.int)(computedStyle.paddingTop);\n    height -= (0, _shims.int)(computedStyle.paddingBottom);\n    return height;\n}\nfunction innerWidth(node /*: HTMLElement*/ ) /*: number*/ {\n    let width = node.clientWidth;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    width -= (0, _shims.int)(computedStyle.paddingLeft);\n    width -= (0, _shims.int)(computedStyle.paddingRight);\n    return width;\n}\n/*:: interface EventWithOffset {\n  clientX: number, clientY: number\n}*/ // Get from offsetParent\nfunction offsetXYFromParent(evt /*: EventWithOffset*/ , offsetParent /*: HTMLElement*/ , scale /*: number*/ ) /*: ControlPosition*/ {\n    const isBody = offsetParent === offsetParent.ownerDocument.body;\n    const offsetParentRect = isBody ? {\n        left: 0,\n        top: 0\n    } : offsetParent.getBoundingClientRect();\n    const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;\n    const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;\n    return {\n        x,\n        y\n    };\n}\nfunction createCSSTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: Object*/ {\n    const translation = getTranslation(controlPos, positionOffset, \"px\");\n    return {\n        [(0, _getPrefix.browserPrefixToKey)(\"transform\", _getPrefix.default)]: translation\n    };\n}\nfunction createSVGTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: string*/ {\n    const translation = getTranslation(controlPos, positionOffset, \"\");\n    return translation;\n}\nfunction getTranslation(_ref /*:: */ , positionOffset /*: PositionOffsetControlPosition*/ , unitSuffix /*: string*/ ) /*: string*/ {\n    let { x, y } /*: ControlPosition*/  = _ref /*: ControlPosition*/ ;\n    let translation = \"translate(\".concat(x).concat(unitSuffix, \",\").concat(y).concat(unitSuffix, \")\");\n    if (positionOffset) {\n        const defaultX = \"\".concat(typeof positionOffset.x === \"string\" ? positionOffset.x : positionOffset.x + unitSuffix);\n        const defaultY = \"\".concat(typeof positionOffset.y === \"string\" ? positionOffset.y : positionOffset.y + unitSuffix);\n        translation = \"translate(\".concat(defaultX, \", \").concat(defaultY, \")\") + translation;\n    }\n    return translation;\n}\nfunction getTouch(e /*: MouseTouchEvent*/ , identifier /*: number*/ ) /*: ?{clientX: number, clientY: number}*/ {\n    return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, (t)=>identifier === t.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, (t)=>identifier === t.identifier);\n}\nfunction getTouchIdentifier(e /*: MouseTouchEvent*/ ) /*: ?number*/ {\n    if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;\n    if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;\n}\n// User-select Hacks:\n//\n// Useful for preventing blue highlights all over everything when dragging.\n// Note we're passing `document` b/c we could be iframed\nfunction addUserSelectStyles(doc /*: ?Document*/ ) {\n    if (!doc) return;\n    let styleEl = doc.getElementById(\"react-draggable-style-el\");\n    if (!styleEl) {\n        styleEl = doc.createElement(\"style\");\n        styleEl.type = \"text/css\";\n        styleEl.id = \"react-draggable-style-el\";\n        styleEl.innerHTML = \".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\\n\";\n        styleEl.innerHTML += \".react-draggable-transparent-selection *::selection {all: inherit;}\\n\";\n        doc.getElementsByTagName(\"head\")[0].appendChild(styleEl);\n    }\n    if (doc.body) addClassName(doc.body, \"react-draggable-transparent-selection\");\n}\nfunction removeUserSelectStyles(doc /*: ?Document*/ ) {\n    if (!doc) return;\n    try {\n        if (doc.body) removeClassName(doc.body, \"react-draggable-transparent-selection\");\n        // $FlowIgnore: IE\n        if (doc.selection) {\n            // $FlowIgnore: IE\n            doc.selection.empty();\n        } else {\n            // Remove selection caused by scroll, unless it's a focused input\n            // (we use doc.defaultView in case we're in an iframe)\n            const selection = (doc.defaultView || window).getSelection();\n            if (selection && selection.type !== \"Caret\") {\n                selection.removeAllRanges();\n            }\n        }\n    } catch (e) {\n    // probably IE\n    }\n}\nfunction addClassName(el /*: HTMLElement*/ , className /*: string*/ ) {\n    if (el.classList) {\n        el.classList.add(className);\n    } else {\n        if (!el.className.match(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\")))) {\n            el.className += \" \".concat(className);\n        }\n    }\n}\nfunction removeClassName(el /*: HTMLElement*/ , className /*: string*/ ) {\n    if (el.classList) {\n        el.classList.remove(className);\n    } else {\n        el.className = el.className.replace(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\"), \"g\"), \"\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9kb21GbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELG9CQUFvQixHQUFHRTtBQUN2QkYsZ0JBQWdCLEdBQUdHO0FBQ25CSCwyQkFBMkIsR0FBR0k7QUFDOUJKLDBCQUEwQixHQUFHSztBQUM3QkwsMEJBQTBCLEdBQUdNO0FBQzdCTixnQkFBZ0IsR0FBR087QUFDbkJQLDBCQUEwQixHQUFHUTtBQUM3QlIsc0JBQXNCLEdBQUdTO0FBQ3pCVCxtQkFBbUIsR0FBR1U7QUFDdEJWLGtCQUFrQixHQUFHVztBQUNyQlgsdUJBQXVCLEdBQUdZO0FBQzFCWixtQ0FBbUMsR0FBR2E7QUFDdENiLDBCQUEwQixHQUFHYztBQUM3QmQsbUJBQW1CLEdBQUdlO0FBQ3RCZixrQkFBa0IsR0FBR2dCO0FBQ3JCaEIsdUJBQXVCLEdBQUdpQjtBQUMxQmpCLG1CQUFtQixHQUFHa0I7QUFDdEJsQiw4QkFBOEIsR0FBR21CO0FBQ2pDLElBQUlDLFNBQVNDLG1CQUFPQSxDQUFDLDhFQUFTO0FBQzlCLElBQUlDLGFBQWFDLHdCQUF3QkYsbUJBQU9BLENBQUMsc0ZBQWE7QUFDOUQsU0FBU0cseUJBQXlCQyxXQUFXO0lBQUksSUFBSSxPQUFPQyxZQUFZLFlBQVksT0FBTztJQUFNLElBQUlDLG9CQUFvQixJQUFJRDtJQUFXLElBQUlFLG1CQUFtQixJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVVDLFdBQVc7UUFBSSxPQUFPQSxjQUFjRyxtQkFBbUJEO0lBQW1CLEdBQUdGO0FBQWM7QUFDdFQsU0FBU0Ysd0JBQXdCTSxHQUFHLEVBQUVKLFdBQVc7SUFBSSxJQUFJLENBQUNBLGVBQWVJLE9BQU9BLElBQUlDLFVBQVUsRUFBRTtRQUFFLE9BQU9EO0lBQUs7SUFBRSxJQUFJQSxRQUFRLFFBQVEsT0FBT0EsUUFBUSxZQUFZLE9BQU9BLFFBQVEsWUFBWTtRQUFFLE9BQU87WUFBRUUsU0FBU0Y7UUFBSTtJQUFHO0lBQUUsSUFBSUcsUUFBUVIseUJBQXlCQztJQUFjLElBQUlPLFNBQVNBLE1BQU1DLEdBQUcsQ0FBQ0osTUFBTTtRQUFFLE9BQU9HLE1BQU1FLEdBQUcsQ0FBQ0w7SUFBTTtJQUFFLElBQUlNLFNBQVMsQ0FBQztJQUFHLElBQUlDLHdCQUF3QnRDLE9BQU9DLGNBQWMsSUFBSUQsT0FBT3VDLHdCQUF3QjtJQUFFLElBQUssSUFBSUMsT0FBT1QsSUFBSztRQUFFLElBQUlTLFFBQVEsYUFBYXhDLE9BQU95QyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDWixLQUFLUyxNQUFNO1lBQUUsSUFBSUksT0FBT04sd0JBQXdCdEMsT0FBT3VDLHdCQUF3QixDQUFDUixLQUFLUyxPQUFPO1lBQU0sSUFBSUksUUFBU0EsQ0FBQUEsS0FBS1IsR0FBRyxJQUFJUSxLQUFLQyxHQUFHLEdBQUc7Z0JBQUU3QyxPQUFPQyxjQUFjLENBQUNvQyxRQUFRRyxLQUFLSTtZQUFPLE9BQU87Z0JBQUVQLE1BQU0sQ0FBQ0csSUFBSSxHQUFHVCxHQUFHLENBQUNTLElBQUk7WUFBRTtRQUFFO0lBQUU7SUFBRUgsT0FBT0osT0FBTyxHQUFHRjtJQUFLLElBQUlHLE9BQU87UUFBRUEsTUFBTVcsR0FBRyxDQUFDZCxLQUFLTTtJQUFTO0lBQUUsT0FBT0E7QUFBUTtBQUNueUIsa0dBQWtHLEdBQ2xHLElBQUlTLHNCQUFzQjtBQUMxQixTQUFTaEMsZ0JBQWdCaUMsR0FBRyxRQUFRLEdBQVQsRUFBYUMsU0FBUyxVQUFVLEdBQVgsRUFBZSxXQUFXO0lBQ3hFLElBQUksQ0FBQ0YscUJBQXFCO1FBQ3hCQSxzQkFBc0IsQ0FBQyxHQUFHeEIsT0FBTzJCLFdBQVcsRUFBRTtZQUFDO1lBQVc7WUFBeUI7WUFBc0I7WUFBcUI7U0FBbUIsRUFBRSxTQUFVQyxNQUFNO1lBQ2pLLG9EQUFvRDtZQUNwRCxPQUFPLENBQUMsR0FBRzVCLE9BQU82QixVQUFVLEVBQUVKLEVBQUUsQ0FBQ0csT0FBTztRQUMxQztJQUNGO0lBRUEscUVBQXFFO0lBQ3JFLG9EQUFvRDtJQUNwRCxJQUFJLENBQUMsQ0FBQyxHQUFHNUIsT0FBTzZCLFVBQVUsRUFBRUosRUFBRSxDQUFDRCxvQkFBb0IsR0FBRyxPQUFPO0lBRTdELG9EQUFvRDtJQUNwRCxPQUFPQyxFQUFFLENBQUNELG9CQUFvQixDQUFDRTtBQUNqQztBQUVBLDBFQUEwRTtBQUMxRSxTQUFTakMsNEJBQTRCZ0MsR0FBRyxRQUFRLEdBQVQsRUFBYUMsU0FBUyxVQUFVLEdBQVgsRUFBZUksU0FBUyxRQUFRLEdBQVQsRUFBYSxXQUFXO0lBQ3pHLElBQUlDLE9BQU9OO0lBQ1gsR0FBRztRQUNELElBQUlqQyxnQkFBZ0J1QyxNQUFNTCxXQUFXLE9BQU87UUFDNUMsSUFBSUssU0FBU0QsVUFBVSxPQUFPO1FBQzlCLGlDQUFpQztRQUNqQ0MsT0FBT0EsS0FBS0MsVUFBVTtJQUN4QixRQUFTRCxNQUFNO0lBQ2YsT0FBTztBQUNUO0FBQ0EsU0FBU2hELFNBQVMwQyxHQUFHLFNBQVMsR0FBVixFQUFjUSxNQUFNLFVBQVUsR0FBWCxFQUFlQyxRQUFRLFlBQVksR0FBYixFQUFpQkMsYUFBYSxVQUFVLEdBQVgsRUFBZSxRQUFRO0lBQy9HLElBQUksQ0FBQ1YsSUFBSTtJQUNULE1BQU1XLFVBQVU7UUFDZEMsU0FBUztRQUNULEdBQUdGLFlBQVk7SUFDakI7SUFDQSxnQ0FBZ0M7SUFDaEMsSUFBSVYsR0FBR2EsZ0JBQWdCLEVBQUU7UUFDdkJiLEdBQUdhLGdCQUFnQixDQUFDTCxPQUFPQyxTQUFTRTtJQUN0QyxPQUFPLElBQUlYLEdBQUdjLFdBQVcsRUFBRTtRQUN6QmQsR0FBR2MsV0FBVyxDQUFDLE9BQU9OLE9BQU9DO0lBQy9CLE9BQU87UUFDTCxvREFBb0Q7UUFDcERULEVBQUUsQ0FBQyxPQUFPUSxNQUFNLEdBQUdDO0lBQ3JCO0FBQ0Y7QUFDQSxTQUFTcEMsWUFBWTJCLEdBQUcsU0FBUyxHQUFWLEVBQWNRLE1BQU0sVUFBVSxHQUFYLEVBQWVDLFFBQVEsWUFBWSxHQUFiLEVBQWlCQyxhQUFhLFVBQVUsR0FBWCxFQUFlLFFBQVE7SUFDbEgsSUFBSSxDQUFDVixJQUFJO0lBQ1QsTUFBTVcsVUFBVTtRQUNkQyxTQUFTO1FBQ1QsR0FBR0YsWUFBWTtJQUNqQjtJQUNBLGdDQUFnQztJQUNoQyxJQUFJVixHQUFHZSxtQkFBbUIsRUFBRTtRQUMxQmYsR0FBR2UsbUJBQW1CLENBQUNQLE9BQU9DLFNBQVNFO0lBQ3pDLE9BQU8sSUFBSVgsR0FBR2dCLFdBQVcsRUFBRTtRQUN6QmhCLEdBQUdnQixXQUFXLENBQUMsT0FBT1IsT0FBT0M7SUFDL0IsT0FBTztRQUNMLG9EQUFvRDtRQUNwRFQsRUFBRSxDQUFDLE9BQU9RLE1BQU0sR0FBRztJQUNyQjtBQUNGO0FBQ0EsU0FBU3RDLFlBQVlvQyxLQUFLLGVBQWUsR0FBaEIsRUFBb0IsVUFBVTtJQUNyRCxpRkFBaUY7SUFDakYsNERBQTREO0lBQzVELElBQUlXLFNBQVNYLEtBQUtZLFlBQVk7SUFDOUIsTUFBTUMsZ0JBQWdCYixLQUFLYyxhQUFhLENBQUNDLFdBQVcsQ0FBQ0MsZ0JBQWdCLENBQUNoQjtJQUN0RVcsVUFBVSxDQUFDLEdBQUcxQyxPQUFPZ0QsR0FBRyxFQUFFSixjQUFjSyxjQUFjO0lBQ3REUCxVQUFVLENBQUMsR0FBRzFDLE9BQU9nRCxHQUFHLEVBQUVKLGNBQWNNLGlCQUFpQjtJQUN6RCxPQUFPUjtBQUNUO0FBQ0EsU0FBUzlDLFdBQVdtQyxLQUFLLGVBQWUsR0FBaEIsRUFBb0IsVUFBVTtJQUNwRCxpRkFBaUY7SUFDakYsNkRBQTZEO0lBQzdELElBQUlvQixRQUFRcEIsS0FBS3FCLFdBQVc7SUFDNUIsTUFBTVIsZ0JBQWdCYixLQUFLYyxhQUFhLENBQUNDLFdBQVcsQ0FBQ0MsZ0JBQWdCLENBQUNoQjtJQUN0RW9CLFNBQVMsQ0FBQyxHQUFHbkQsT0FBT2dELEdBQUcsRUFBRUosY0FBY1MsZUFBZTtJQUN0REYsU0FBUyxDQUFDLEdBQUduRCxPQUFPZ0QsR0FBRyxFQUFFSixjQUFjVSxnQkFBZ0I7SUFDdkQsT0FBT0g7QUFDVDtBQUNBLFNBQVM3RCxZQUFZeUMsS0FBSyxlQUFlLEdBQWhCLEVBQW9CLFVBQVU7SUFDckQsSUFBSVcsU0FBU1gsS0FBS1ksWUFBWTtJQUM5QixNQUFNQyxnQkFBZ0JiLEtBQUtjLGFBQWEsQ0FBQ0MsV0FBVyxDQUFDQyxnQkFBZ0IsQ0FBQ2hCO0lBQ3RFVyxVQUFVLENBQUMsR0FBRzFDLE9BQU9nRCxHQUFHLEVBQUVKLGNBQWNXLFVBQVU7SUFDbERiLFVBQVUsQ0FBQyxHQUFHMUMsT0FBT2dELEdBQUcsRUFBRUosY0FBY1ksYUFBYTtJQUNyRCxPQUFPZDtBQUNUO0FBQ0EsU0FBU25ELFdBQVd3QyxLQUFLLGVBQWUsR0FBaEIsRUFBb0IsVUFBVTtJQUNwRCxJQUFJb0IsUUFBUXBCLEtBQUtxQixXQUFXO0lBQzVCLE1BQU1SLGdCQUFnQmIsS0FBS2MsYUFBYSxDQUFDQyxXQUFXLENBQUNDLGdCQUFnQixDQUFDaEI7SUFDdEVvQixTQUFTLENBQUMsR0FBR25ELE9BQU9nRCxHQUFHLEVBQUVKLGNBQWNhLFdBQVc7SUFDbEROLFNBQVMsQ0FBQyxHQUFHbkQsT0FBT2dELEdBQUcsRUFBRUosY0FBY2MsWUFBWTtJQUNuRCxPQUFPUDtBQUNUO0FBQ0E7O0NBRUMsR0FDRCx3QkFBd0I7QUFDeEIsU0FBU3pELG1CQUFtQmlFLElBQUksbUJBQW1CLEdBQXBCLEVBQXdCQyxhQUFhLGVBQWUsR0FBaEIsRUFBb0JDLE1BQU0sVUFBVSxHQUFYLEVBQWUsbUJBQW1CO0lBQzVILE1BQU1DLFNBQVNGLGlCQUFpQkEsYUFBYWYsYUFBYSxDQUFDa0IsSUFBSTtJQUMvRCxNQUFNQyxtQkFBbUJGLFNBQVM7UUFDaENHLE1BQU07UUFDTkMsS0FBSztJQUNQLElBQUlOLGFBQWFPLHFCQUFxQjtJQUN0QyxNQUFNQyxJQUFJLENBQUNULElBQUlVLE9BQU8sR0FBR1QsYUFBYVUsVUFBVSxHQUFHTixpQkFBaUJDLElBQUksSUFBSUo7SUFDNUUsTUFBTVUsSUFBSSxDQUFDWixJQUFJYSxPQUFPLEdBQUdaLGFBQWFhLFNBQVMsR0FBR1QsaUJBQWlCRSxHQUFHLElBQUlMO0lBQzFFLE9BQU87UUFDTE87UUFDQUc7SUFDRjtBQUNGO0FBQ0EsU0FBU3RGLG1CQUFtQnlGLFdBQVcsbUJBQW1CLEdBQXBCLEVBQXdCQyxlQUFlLGlDQUFpQyxHQUFsQyxFQUFzQyxVQUFVO0lBQzFILE1BQU1DLGNBQWN2RixlQUFlcUYsWUFBWUMsZ0JBQWdCO0lBQy9ELE9BQU87UUFDTCxDQUFDLENBQUMsR0FBR3pFLFdBQVcyRSxrQkFBa0IsRUFBRSxhQUFhM0UsV0FBV1MsT0FBTyxFQUFFLEVBQUVpRTtJQUN6RTtBQUNGO0FBQ0EsU0FBUzFGLG1CQUFtQndGLFdBQVcsbUJBQW1CLEdBQXBCLEVBQXdCQyxlQUFlLGlDQUFpQyxHQUFsQyxFQUFzQyxVQUFVO0lBQzFILE1BQU1DLGNBQWN2RixlQUFlcUYsWUFBWUMsZ0JBQWdCO0lBQy9ELE9BQU9DO0FBQ1Q7QUFDQSxTQUFTdkYsZUFBZXlGLEtBQUssS0FBSyxHQUFOLEVBQVVILGVBQWUsaUNBQWlDLEdBQWxDLEVBQXNDSSxXQUFXLFVBQVUsR0FBWCxFQUFlLFVBQVU7SUFDM0gsSUFBSSxFQUNGWCxDQUFDLEVBQ0RHLENBQUMsRUFDRixDQUFDLG1CQUFtQixNQUFLTyxLQUFLLG1CQUFtQjtJQUNsRCxJQUFJRixjQUFjLGFBQWFJLE1BQU0sQ0FBQ1osR0FBR1ksTUFBTSxDQUFDRCxZQUFZLEtBQUtDLE1BQU0sQ0FBQ1QsR0FBR1MsTUFBTSxDQUFDRCxZQUFZO0lBQzlGLElBQUlKLGdCQUFnQjtRQUNsQixNQUFNTSxXQUFXLEdBQUdELE1BQU0sQ0FBQyxPQUFPTCxlQUFlUCxDQUFDLEtBQUssV0FBV08sZUFBZVAsQ0FBQyxHQUFHTyxlQUFlUCxDQUFDLEdBQUdXO1FBQ3hHLE1BQU1HLFdBQVcsR0FBR0YsTUFBTSxDQUFDLE9BQU9MLGVBQWVKLENBQUMsS0FBSyxXQUFXSSxlQUFlSixDQUFDLEdBQUdJLGVBQWVKLENBQUMsR0FBR1E7UUFDeEdILGNBQWMsYUFBYUksTUFBTSxDQUFDQyxVQUFVLE1BQU1ELE1BQU0sQ0FBQ0UsVUFBVSxPQUFPTjtJQUM1RTtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTekYsU0FBU2dHLEVBQUUsbUJBQW1CLEdBQXBCLEVBQXdCQyxXQUFXLFVBQVUsR0FBWCxFQUFlLHVDQUF1QztJQUN6RyxPQUFPRCxFQUFFRSxhQUFhLElBQUksQ0FBQyxHQUFHckYsT0FBTzJCLFdBQVcsRUFBRXdELEVBQUVFLGFBQWEsRUFBRUMsQ0FBQUEsSUFBS0YsZUFBZUUsRUFBRUYsVUFBVSxLQUFLRCxFQUFFSSxjQUFjLElBQUksQ0FBQyxHQUFHdkYsT0FBTzJCLFdBQVcsRUFBRXdELEVBQUVJLGNBQWMsRUFBRUQsQ0FBQUEsSUFBS0YsZUFBZUUsRUFBRUYsVUFBVTtBQUN4TTtBQUNBLFNBQVNoRyxtQkFBbUIrRixFQUFFLG1CQUFtQixHQUFwQixFQUF3QixXQUFXO0lBQzlELElBQUlBLEVBQUVFLGFBQWEsSUFBSUYsRUFBRUUsYUFBYSxDQUFDLEVBQUUsRUFBRSxPQUFPRixFQUFFRSxhQUFhLENBQUMsRUFBRSxDQUFDRCxVQUFVO0lBQy9FLElBQUlELEVBQUVJLGNBQWMsSUFBSUosRUFBRUksY0FBYyxDQUFDLEVBQUUsRUFBRSxPQUFPSixFQUFFSSxjQUFjLENBQUMsRUFBRSxDQUFDSCxVQUFVO0FBQ3BGO0FBRUEscUJBQXFCO0FBQ3JCLEVBQUU7QUFDRiwyRUFBMkU7QUFFM0Usd0RBQXdEO0FBQ3hELFNBQVNwRyxvQkFBb0J3RyxJQUFJLGFBQWEsR0FBZDtJQUM5QixJQUFJLENBQUNBLEtBQUs7SUFDVixJQUFJQyxVQUFVRCxJQUFJRSxjQUFjLENBQUM7SUFDakMsSUFBSSxDQUFDRCxTQUFTO1FBQ1pBLFVBQVVELElBQUlHLGFBQWEsQ0FBQztRQUM1QkYsUUFBUUcsSUFBSSxHQUFHO1FBQ2ZILFFBQVFJLEVBQUUsR0FBRztRQUNiSixRQUFRSyxTQUFTLEdBQUc7UUFDcEJMLFFBQVFLLFNBQVMsSUFBSTtRQUNyQk4sSUFBSU8sb0JBQW9CLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQ0MsV0FBVyxDQUFDUDtJQUNsRDtJQUNBLElBQUlELElBQUl6QixJQUFJLEVBQUVqRixhQUFhMEcsSUFBSXpCLElBQUksRUFBRTtBQUN2QztBQUNBLFNBQVNoRSx1QkFBdUJ5RixJQUFJLGFBQWEsR0FBZDtJQUNqQyxJQUFJLENBQUNBLEtBQUs7SUFDVixJQUFJO1FBQ0YsSUFBSUEsSUFBSXpCLElBQUksRUFBRWxFLGdCQUFnQjJGLElBQUl6QixJQUFJLEVBQUU7UUFDeEMsa0JBQWtCO1FBQ2xCLElBQUl5QixJQUFJUyxTQUFTLEVBQUU7WUFDakIsa0JBQWtCO1lBQ2xCVCxJQUFJUyxTQUFTLENBQUNDLEtBQUs7UUFDckIsT0FBTztZQUNMLGlFQUFpRTtZQUNqRSxzREFBc0Q7WUFDdEQsTUFBTUQsWUFBWSxDQUFDVCxJQUFJMUMsV0FBVyxJQUFJcUQsTUFBSyxFQUFHQyxZQUFZO1lBQzFELElBQUlILGFBQWFBLFVBQVVMLElBQUksS0FBSyxTQUFTO2dCQUMzQ0ssVUFBVUksZUFBZTtZQUMzQjtRQUNGO0lBQ0YsRUFBRSxPQUFPbEIsR0FBRztJQUNWLGNBQWM7SUFDaEI7QUFDRjtBQUNBLFNBQVNyRyxhQUFhMkMsR0FBRyxlQUFlLEdBQWhCLEVBQW9CNkUsVUFBVSxVQUFVLEdBQVg7SUFDbkQsSUFBSTdFLEdBQUc4RSxTQUFTLEVBQUU7UUFDaEI5RSxHQUFHOEUsU0FBUyxDQUFDQyxHQUFHLENBQUNGO0lBQ25CLE9BQU87UUFDTCxJQUFJLENBQUM3RSxHQUFHNkUsU0FBUyxDQUFDRyxLQUFLLENBQUMsSUFBSUMsT0FBTyxZQUFZMUIsTUFBTSxDQUFDc0IsV0FBVyxjQUFjO1lBQzdFN0UsR0FBRzZFLFNBQVMsSUFBSSxJQUFJdEIsTUFBTSxDQUFDc0I7UUFDN0I7SUFDRjtBQUNGO0FBQ0EsU0FBU3pHLGdCQUFnQjRCLEdBQUcsZUFBZSxHQUFoQixFQUFvQjZFLFVBQVUsVUFBVSxHQUFYO0lBQ3RELElBQUk3RSxHQUFHOEUsU0FBUyxFQUFFO1FBQ2hCOUUsR0FBRzhFLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDTDtJQUN0QixPQUFPO1FBQ0w3RSxHQUFHNkUsU0FBUyxHQUFHN0UsR0FBRzZFLFNBQVMsQ0FBQ00sT0FBTyxDQUFDLElBQUlGLE9BQU8sWUFBWTFCLE1BQU0sQ0FBQ3NCLFdBQVcsWUFBWSxNQUFNO0lBQ2pHO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmFzb3JfY2xvbmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9kb21GbnMuanM/MzlhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRkQ2xhc3NOYW1lID0gYWRkQ2xhc3NOYW1lO1xuZXhwb3J0cy5hZGRFdmVudCA9IGFkZEV2ZW50O1xuZXhwb3J0cy5hZGRVc2VyU2VsZWN0U3R5bGVzID0gYWRkVXNlclNlbGVjdFN0eWxlcztcbmV4cG9ydHMuY3JlYXRlQ1NTVHJhbnNmb3JtID0gY3JlYXRlQ1NTVHJhbnNmb3JtO1xuZXhwb3J0cy5jcmVhdGVTVkdUcmFuc2Zvcm0gPSBjcmVhdGVTVkdUcmFuc2Zvcm07XG5leHBvcnRzLmdldFRvdWNoID0gZ2V0VG91Y2g7XG5leHBvcnRzLmdldFRvdWNoSWRlbnRpZmllciA9IGdldFRvdWNoSWRlbnRpZmllcjtcbmV4cG9ydHMuZ2V0VHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbjtcbmV4cG9ydHMuaW5uZXJIZWlnaHQgPSBpbm5lckhlaWdodDtcbmV4cG9ydHMuaW5uZXJXaWR0aCA9IGlubmVyV2lkdGg7XG5leHBvcnRzLm1hdGNoZXNTZWxlY3RvciA9IG1hdGNoZXNTZWxlY3RvcjtcbmV4cG9ydHMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvID0gbWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvO1xuZXhwb3J0cy5vZmZzZXRYWUZyb21QYXJlbnQgPSBvZmZzZXRYWUZyb21QYXJlbnQ7XG5leHBvcnRzLm91dGVySGVpZ2h0ID0gb3V0ZXJIZWlnaHQ7XG5leHBvcnRzLm91dGVyV2lkdGggPSBvdXRlcldpZHRoO1xuZXhwb3J0cy5yZW1vdmVDbGFzc05hbWUgPSByZW1vdmVDbGFzc05hbWU7XG5leHBvcnRzLnJlbW92ZUV2ZW50ID0gcmVtb3ZlRXZlbnQ7XG5leHBvcnRzLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMgPSByZW1vdmVVc2VyU2VsZWN0U3R5bGVzO1xudmFyIF9zaGltcyA9IHJlcXVpcmUoXCIuL3NoaW1zXCIpO1xudmFyIF9nZXRQcmVmaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9nZXRQcmVmaXhcIikpO1xuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIChub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG4vKjo6IGltcG9ydCB0eXBlIHtDb250cm9sUG9zaXRpb24sIFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uLCBNb3VzZVRvdWNoRXZlbnR9IGZyb20gJy4vdHlwZXMnOyovXG5sZXQgbWF0Y2hlc1NlbGVjdG9yRnVuYyA9ICcnO1xuZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yKGVsIC8qOiBOb2RlKi8sIHNlbGVjdG9yIC8qOiBzdHJpbmcqLykgLyo6IGJvb2xlYW4qL3tcbiAgaWYgKCFtYXRjaGVzU2VsZWN0b3JGdW5jKSB7XG4gICAgbWF0Y2hlc1NlbGVjdG9yRnVuYyA9ICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKFsnbWF0Y2hlcycsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbW96TWF0Y2hlc1NlbGVjdG9yJywgJ21zTWF0Y2hlc1NlbGVjdG9yJywgJ29NYXRjaGVzU2VsZWN0b3InXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICAgICAgcmV0dXJuICgwLCBfc2hpbXMuaXNGdW5jdGlvbikoZWxbbWV0aG9kXSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBNaWdodCBub3QgYmUgZm91bmQgZW50aXJlbHkgKG5vdCBhbiBFbGVtZW50PykgLSBpbiB0aGF0IGNhc2UsIGJhaWxcbiAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICBpZiAoISgwLCBfc2hpbXMuaXNGdW5jdGlvbikoZWxbbWF0Y2hlc1NlbGVjdG9yRnVuY10pKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICByZXR1cm4gZWxbbWF0Y2hlc1NlbGVjdG9yRnVuY10oc2VsZWN0b3IpO1xufVxuXG4vLyBXb3JrcyB1cCB0aGUgdHJlZSB0byB0aGUgZHJhZ2dhYmxlIGl0c2VsZiBhdHRlbXB0aW5nIHRvIG1hdGNoIHNlbGVjdG9yLlxuZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKGVsIC8qOiBOb2RlKi8sIHNlbGVjdG9yIC8qOiBzdHJpbmcqLywgYmFzZU5vZGUgLyo6IE5vZGUqLykgLyo6IGJvb2xlYW4qL3tcbiAgbGV0IG5vZGUgPSBlbDtcbiAgZG8ge1xuICAgIGlmIChtYXRjaGVzU2VsZWN0b3Iobm9kZSwgc2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobm9kZSA9PT0gYmFzZU5vZGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyAkRmxvd0lnbm9yZVtpbmNvbXBhdGlibGUtdHlwZV1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9IHdoaWxlIChub2RlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWRkRXZlbnQoZWwgLyo6ID9Ob2RlKi8sIGV2ZW50IC8qOiBzdHJpbmcqLywgaGFuZGxlciAvKjogRnVuY3Rpb24qLywgaW5wdXRPcHRpb25zIC8qOiBPYmplY3QqLykgLyo6IHZvaWQqL3tcbiAgaWYgKCFlbCkgcmV0dXJuO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgLi4uaW5wdXRPcHRpb25zXG4gIH07XG4gIC8vICRGbG93SWdub3JlW21ldGhvZC11bmJpbmRpbmddXG4gIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgICBlbFsnb24nICsgZXZlbnRdID0gaGFuZGxlcjtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWwgLyo6ID9Ob2RlKi8sIGV2ZW50IC8qOiBzdHJpbmcqLywgaGFuZGxlciAvKjogRnVuY3Rpb24qLywgaW5wdXRPcHRpb25zIC8qOiBPYmplY3QqLykgLyo6IHZvaWQqL3tcbiAgaWYgKCFlbCkgcmV0dXJuO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgLi4uaW5wdXRPcHRpb25zXG4gIH07XG4gIC8vICRGbG93SWdub3JlW21ldGhvZC11bmJpbmRpbmddXG4gIGlmIChlbC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoZWwuZGV0YWNoRXZlbnQpIHtcbiAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgICBlbFsnb24nICsgZXZlbnRdID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gb3V0ZXJIZWlnaHQobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciove1xuICAvLyBUaGlzIGlzIGRlbGliZXJhdGVseSBleGNsdWRpbmcgbWFyZ2luIGZvciBvdXIgY2FsY3VsYXRpb25zLCBzaW5jZSB3ZSBhcmUgdXNpbmdcbiAgLy8gb2Zmc2V0VG9wIHdoaWNoIGlzIGluY2x1ZGluZyBtYXJnaW4uIFNlZSBnZXRCb3VuZFBvc2l0aW9uXG4gIGxldCBoZWlnaHQgPSBub2RlLmNsaWVudEhlaWdodDtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICBoZWlnaHQgKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgpO1xuICBoZWlnaHQgKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpO1xuICByZXR1cm4gaGVpZ2h0O1xufVxuZnVuY3Rpb24gb3V0ZXJXaWR0aChub2RlIC8qOiBIVE1MRWxlbWVudCovKSAvKjogbnVtYmVyKi97XG4gIC8vIFRoaXMgaXMgZGVsaWJlcmF0ZWx5IGV4Y2x1ZGluZyBtYXJnaW4gZm9yIG91ciBjYWxjdWxhdGlvbnMsIHNpbmNlIHdlIGFyZSB1c2luZ1xuICAvLyBvZmZzZXRMZWZ0IHdoaWNoIGlzIGluY2x1ZGluZyBtYXJnaW4uIFNlZSBnZXRCb3VuZFBvc2l0aW9uXG4gIGxldCB3aWR0aCA9IG5vZGUuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgd2lkdGggKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoKTtcbiAgd2lkdGggKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCk7XG4gIHJldHVybiB3aWR0aDtcbn1cbmZ1bmN0aW9uIGlubmVySGVpZ2h0KG5vZGUgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBudW1iZXIqL3tcbiAgbGV0IGhlaWdodCA9IG5vZGUuY2xpZW50SGVpZ2h0O1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGhlaWdodCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nVG9wKTtcbiAgaGVpZ2h0IC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20pO1xuICByZXR1cm4gaGVpZ2h0O1xufVxuZnVuY3Rpb24gaW5uZXJXaWR0aChub2RlIC8qOiBIVE1MRWxlbWVudCovKSAvKjogbnVtYmVyKi97XG4gIGxldCB3aWR0aCA9IG5vZGUuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgd2lkdGggLT0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpO1xuICB3aWR0aCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICByZXR1cm4gd2lkdGg7XG59XG4vKjo6IGludGVyZmFjZSBFdmVudFdpdGhPZmZzZXQge1xuICBjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlclxufSovXG4vLyBHZXQgZnJvbSBvZmZzZXRQYXJlbnRcbmZ1bmN0aW9uIG9mZnNldFhZRnJvbVBhcmVudChldnQgLyo6IEV2ZW50V2l0aE9mZnNldCovLCBvZmZzZXRQYXJlbnQgLyo6IEhUTUxFbGVtZW50Ki8sIHNjYWxlIC8qOiBudW1iZXIqLykgLyo6IENvbnRyb2xQb3NpdGlvbiove1xuICBjb25zdCBpc0JvZHkgPSBvZmZzZXRQYXJlbnQgPT09IG9mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IG9mZnNldFBhcmVudFJlY3QgPSBpc0JvZHkgPyB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDBcbiAgfSA6IG9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgeCA9IChldnQuY2xpZW50WCArIG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0IC0gb2Zmc2V0UGFyZW50UmVjdC5sZWZ0KSAvIHNjYWxlO1xuICBjb25zdCB5ID0gKGV2dC5jbGllbnRZICsgb2Zmc2V0UGFyZW50LnNjcm9sbFRvcCAtIG9mZnNldFBhcmVudFJlY3QudG9wKSAvIHNjYWxlO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ1NTVHJhbnNmb3JtKGNvbnRyb2xQb3MgLyo6IENvbnRyb2xQb3NpdGlvbiovLCBwb3NpdGlvbk9mZnNldCAvKjogUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24qLykgLyo6IE9iamVjdCove1xuICBjb25zdCB0cmFuc2xhdGlvbiA9IGdldFRyYW5zbGF0aW9uKGNvbnRyb2xQb3MsIHBvc2l0aW9uT2Zmc2V0LCAncHgnKTtcbiAgcmV0dXJuIHtcbiAgICBbKDAsIF9nZXRQcmVmaXguYnJvd3NlclByZWZpeFRvS2V5KSgndHJhbnNmb3JtJywgX2dldFByZWZpeC5kZWZhdWx0KV06IHRyYW5zbGF0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTVkdUcmFuc2Zvcm0oY29udHJvbFBvcyAvKjogQ29udHJvbFBvc2l0aW9uKi8sIHBvc2l0aW9uT2Zmc2V0IC8qOiBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbiovKSAvKjogc3RyaW5nKi97XG4gIGNvbnN0IHRyYW5zbGF0aW9uID0gZ2V0VHJhbnNsYXRpb24oY29udHJvbFBvcywgcG9zaXRpb25PZmZzZXQsICcnKTtcbiAgcmV0dXJuIHRyYW5zbGF0aW9uO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24oX3JlZiAvKjo6ICovLCBwb3NpdGlvbk9mZnNldCAvKjogUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24qLywgdW5pdFN1ZmZpeCAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqL3tcbiAgbGV0IHtcbiAgICB4LFxuICAgIHlcbiAgfSAvKjogQ29udHJvbFBvc2l0aW9uKi8gPSBfcmVmIC8qOiBDb250cm9sUG9zaXRpb24qLztcbiAgbGV0IHRyYW5zbGF0aW9uID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHgpLmNvbmNhdCh1bml0U3VmZml4LCBcIixcIikuY29uY2F0KHkpLmNvbmNhdCh1bml0U3VmZml4LCBcIilcIik7XG4gIGlmIChwb3NpdGlvbk9mZnNldCkge1xuICAgIGNvbnN0IGRlZmF1bHRYID0gXCJcIi5jb25jYXQodHlwZW9mIHBvc2l0aW9uT2Zmc2V0LnggPT09ICdzdHJpbmcnID8gcG9zaXRpb25PZmZzZXQueCA6IHBvc2l0aW9uT2Zmc2V0LnggKyB1bml0U3VmZml4KTtcbiAgICBjb25zdCBkZWZhdWx0WSA9IFwiXCIuY29uY2F0KHR5cGVvZiBwb3NpdGlvbk9mZnNldC55ID09PSAnc3RyaW5nJyA/IHBvc2l0aW9uT2Zmc2V0LnkgOiBwb3NpdGlvbk9mZnNldC55ICsgdW5pdFN1ZmZpeCk7XG4gICAgdHJhbnNsYXRpb24gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQoZGVmYXVsdFgsIFwiLCBcIikuY29uY2F0KGRlZmF1bHRZLCBcIilcIikgKyB0cmFuc2xhdGlvbjtcbiAgfVxuICByZXR1cm4gdHJhbnNsYXRpb247XG59XG5mdW5jdGlvbiBnZXRUb3VjaChlIC8qOiBNb3VzZVRvdWNoRXZlbnQqLywgaWRlbnRpZmllciAvKjogbnVtYmVyKi8pIC8qOiA/e2NsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyfSove1xuICByZXR1cm4gZS50YXJnZXRUb3VjaGVzICYmICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKGUudGFyZ2V0VG91Y2hlcywgdCA9PiBpZGVudGlmaWVyID09PSB0LmlkZW50aWZpZXIpIHx8IGUuY2hhbmdlZFRvdWNoZXMgJiYgKDAsIF9zaGltcy5maW5kSW5BcnJheSkoZS5jaGFuZ2VkVG91Y2hlcywgdCA9PiBpZGVudGlmaWVyID09PSB0LmlkZW50aWZpZXIpO1xufVxuZnVuY3Rpb24gZ2V0VG91Y2hJZGVudGlmaWVyKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovKSAvKjogP251bWJlciove1xuICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlc1swXSkgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyO1xuICBpZiAoZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzWzBdKSByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyO1xufVxuXG4vLyBVc2VyLXNlbGVjdCBIYWNrczpcbi8vXG4vLyBVc2VmdWwgZm9yIHByZXZlbnRpbmcgYmx1ZSBoaWdobGlnaHRzIGFsbCBvdmVyIGV2ZXJ5dGhpbmcgd2hlbiBkcmFnZ2luZy5cblxuLy8gTm90ZSB3ZSdyZSBwYXNzaW5nIGBkb2N1bWVudGAgYi9jIHdlIGNvdWxkIGJlIGlmcmFtZWRcbmZ1bmN0aW9uIGFkZFVzZXJTZWxlY3RTdHlsZXMoZG9jIC8qOiA/RG9jdW1lbnQqLykge1xuICBpZiAoIWRvYykgcmV0dXJuO1xuICBsZXQgc3R5bGVFbCA9IGRvYy5nZXRFbGVtZW50QnlJZCgncmVhY3QtZHJhZ2dhYmxlLXN0eWxlLWVsJyk7XG4gIGlmICghc3R5bGVFbCkge1xuICAgIHN0eWxlRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZUVsLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIHN0eWxlRWwuaWQgPSAncmVhY3QtZHJhZ2dhYmxlLXN0eWxlLWVsJztcbiAgICBzdHlsZUVsLmlubmVySFRNTCA9ICcucmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbiAqOjotbW96LXNlbGVjdGlvbiB7YWxsOiBpbmhlcml0O31cXG4nO1xuICAgIHN0eWxlRWwuaW5uZXJIVE1MICs9ICcucmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbiAqOjpzZWxlY3Rpb24ge2FsbDogaW5oZXJpdDt9XFxuJztcbiAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZUVsKTtcbiAgfVxuICBpZiAoZG9jLmJvZHkpIGFkZENsYXNzTmFtZShkb2MuYm9keSwgJ3JlYWN0LWRyYWdnYWJsZS10cmFuc3BhcmVudC1zZWxlY3Rpb24nKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVVzZXJTZWxlY3RTdHlsZXMoZG9jIC8qOiA/RG9jdW1lbnQqLykge1xuICBpZiAoIWRvYykgcmV0dXJuO1xuICB0cnkge1xuICAgIGlmIChkb2MuYm9keSkgcmVtb3ZlQ2xhc3NOYW1lKGRvYy5ib2R5LCAncmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbicpO1xuICAgIC8vICRGbG93SWdub3JlOiBJRVxuICAgIGlmIChkb2Muc2VsZWN0aW9uKSB7XG4gICAgICAvLyAkRmxvd0lnbm9yZTogSUVcbiAgICAgIGRvYy5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIHNlbGVjdGlvbiBjYXVzZWQgYnkgc2Nyb2xsLCB1bmxlc3MgaXQncyBhIGZvY3VzZWQgaW5wdXRcbiAgICAgIC8vICh3ZSB1c2UgZG9jLmRlZmF1bHRWaWV3IGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lKVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gKGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24udHlwZSAhPT0gJ0NhcmV0Jykge1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gcHJvYmFibHkgSUVcbiAgfVxufVxuZnVuY3Rpb24gYWRkQ2xhc3NOYW1lKGVsIC8qOiBIVE1MRWxlbWVudCovLCBjbGFzc05hbWUgLyo6IHN0cmluZyovKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFlbC5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIoPyFcXFxcUylcIikpKSkge1xuICAgICAgZWwuY2xhc3NOYW1lICs9IFwiIFwiLmNvbmNhdChjbGFzc05hbWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lKGVsIC8qOiBIVE1MRWxlbWVudCovLCBjbGFzc05hbWUgLyo6IHN0cmluZyovKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIoPyFcXFxcUylcIiksICdnJyksICcnKTtcbiAgfVxufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZENsYXNzTmFtZSIsImFkZEV2ZW50IiwiYWRkVXNlclNlbGVjdFN0eWxlcyIsImNyZWF0ZUNTU1RyYW5zZm9ybSIsImNyZWF0ZVNWR1RyYW5zZm9ybSIsImdldFRvdWNoIiwiZ2V0VG91Y2hJZGVudGlmaWVyIiwiZ2V0VHJhbnNsYXRpb24iLCJpbm5lckhlaWdodCIsImlubmVyV2lkdGgiLCJtYXRjaGVzU2VsZWN0b3IiLCJtYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG8iLCJvZmZzZXRYWUZyb21QYXJlbnQiLCJvdXRlckhlaWdodCIsIm91dGVyV2lkdGgiLCJyZW1vdmVDbGFzc05hbWUiLCJyZW1vdmVFdmVudCIsInJlbW92ZVVzZXJTZWxlY3RTdHlsZXMiLCJfc2hpbXMiLCJyZXF1aXJlIiwiX2dldFByZWZpeCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwibm9kZUludGVyb3AiLCJXZWFrTWFwIiwiY2FjaGVCYWJlbEludGVyb3AiLCJjYWNoZU5vZGVJbnRlcm9wIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjYWNoZSIsImhhcyIsImdldCIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlc2MiLCJzZXQiLCJtYXRjaGVzU2VsZWN0b3JGdW5jIiwiZWwiLCJzZWxlY3RvciIsImZpbmRJbkFycmF5IiwibWV0aG9kIiwiaXNGdW5jdGlvbiIsImJhc2VOb2RlIiwibm9kZSIsInBhcmVudE5vZGUiLCJldmVudCIsImhhbmRsZXIiLCJpbnB1dE9wdGlvbnMiLCJvcHRpb25zIiwiY2FwdHVyZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImNvbXB1dGVkU3R5bGUiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJnZXRDb21wdXRlZFN0eWxlIiwiaW50IiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodFdpZHRoIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImV2dCIsIm9mZnNldFBhcmVudCIsInNjYWxlIiwiaXNCb2R5IiwiYm9keSIsIm9mZnNldFBhcmVudFJlY3QiLCJsZWZ0IiwidG9wIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsImNsaWVudFgiLCJzY3JvbGxMZWZ0IiwieSIsImNsaWVudFkiLCJzY3JvbGxUb3AiLCJjb250cm9sUG9zIiwicG9zaXRpb25PZmZzZXQiLCJ0cmFuc2xhdGlvbiIsImJyb3dzZXJQcmVmaXhUb0tleSIsIl9yZWYiLCJ1bml0U3VmZml4IiwiY29uY2F0IiwiZGVmYXVsdFgiLCJkZWZhdWx0WSIsImUiLCJpZGVudGlmaWVyIiwidGFyZ2V0VG91Y2hlcyIsInQiLCJjaGFuZ2VkVG91Y2hlcyIsImRvYyIsInN0eWxlRWwiLCJnZXRFbGVtZW50QnlJZCIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiaWQiLCJpbm5lckhUTUwiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImFwcGVuZENoaWxkIiwic2VsZWN0aW9uIiwiZW1wdHkiLCJ3aW5kb3ciLCJnZXRTZWxlY3Rpb24iLCJyZW1vdmVBbGxSYW5nZXMiLCJjbGFzc05hbWUiLCJjbGFzc0xpc3QiLCJhZGQiLCJtYXRjaCIsIlJlZ0V4cCIsInJlbW92ZSIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/utils/domFns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/utils/getPrefix.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/getPrefix.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.browserPrefixToKey = browserPrefixToKey;\nexports.browserPrefixToStyle = browserPrefixToStyle;\nexports[\"default\"] = void 0;\nexports.getPrefix = getPrefix;\nconst prefixes = [\n    \"Moz\",\n    \"Webkit\",\n    \"O\",\n    \"ms\"\n];\nfunction getPrefix() /*: string*/ {\n    var _window$document;\n    let prop /*: string*/  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"transform\";\n    // Ensure we're running in an environment where there is actually a global\n    // `window` obj\n    if (true) return \"\";\n    // If we're in a pseudo-browser server-side environment, this access\n    // path may not exist, so bail out if it doesn't.\n    const style = (_window$document = window.document) === null || _window$document === void 0 || (_window$document = _window$document.documentElement) === null || _window$document === void 0 ? void 0 : _window$document.style;\n    if (!style) return \"\";\n    if (prop in style) return \"\";\n    for(let i = 0; i < prefixes.length; i++){\n        if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];\n    }\n    return \"\";\n}\nfunction browserPrefixToKey(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {\n    return prefix ? \"\".concat(prefix).concat(kebabToTitleCase(prop)) : prop;\n}\nfunction browserPrefixToStyle(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {\n    return prefix ? \"-\".concat(prefix.toLowerCase(), \"-\").concat(prop) : prop;\n}\nfunction kebabToTitleCase(str /*: string*/ ) /*: string*/ {\n    let out = \"\";\n    let shouldCapitalize = true;\n    for(let i = 0; i < str.length; i++){\n        if (shouldCapitalize) {\n            out += str[i].toUpperCase();\n            shouldCapitalize = false;\n        } else if (str[i] === \"-\") {\n            shouldCapitalize = true;\n        } else {\n            out += str[i];\n        }\n    }\n    return out;\n}\n// Default export is the prefix itself, like 'Moz', 'Webkit', etc\n// Note that you may have to re-test for certain things; for instance, Chrome 50\n// can handle unprefixed `transform`, but not unprefixed `user-select`\nvar _default = exports[\"default\"] = getPrefix();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9nZXRQcmVmaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHRTtBQUM3QkYsNEJBQTRCLEdBQUdHO0FBQy9CSCxrQkFBZSxHQUFHLEtBQUs7QUFDdkJBLGlCQUFpQixHQUFHSztBQUNwQixNQUFNQyxXQUFXO0lBQUM7SUFBTztJQUFVO0lBQUs7Q0FBSztBQUM3QyxTQUFTRCxZQUFZLFVBQVU7SUFDN0IsSUFBSUU7SUFDSixJQUFJQyxLQUFLLFVBQVUsTUFBS0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDNUYsMEVBQTBFO0lBQzFFLGVBQWU7SUFDZixJQUFJLElBQWtCLEVBQWEsT0FBTztJQUUxQyxvRUFBb0U7SUFDcEUsaURBQWlEO0lBQ2pELE1BQU1HLFFBQVEsQ0FBQ0wsbUJBQW1CTSxPQUFPQyxRQUFRLE1BQU0sUUFBUVAscUJBQXFCLEtBQUssS0FBSyxDQUFDQSxtQkFBbUJBLGlCQUFpQlEsZUFBZSxNQUFNLFFBQVFSLHFCQUFxQixLQUFLLElBQUksS0FBSyxJQUFJQSxpQkFBaUJLLEtBQUs7SUFDN04sSUFBSSxDQUFDQSxPQUFPLE9BQU87SUFDbkIsSUFBSUosUUFBUUksT0FBTyxPQUFPO0lBQzFCLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJVixTQUFTSSxNQUFNLEVBQUVNLElBQUs7UUFDeEMsSUFBSWQsbUJBQW1CTSxNQUFNRixRQUFRLENBQUNVLEVBQUUsS0FBS0osT0FBTyxPQUFPTixRQUFRLENBQUNVLEVBQUU7SUFDeEU7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTZCxtQkFBbUJNLEtBQUssVUFBVSxHQUFYLEVBQWVTLE9BQU8sVUFBVSxHQUFYLEVBQWUsVUFBVTtJQUM1RSxPQUFPQSxTQUFTLEdBQUdDLE1BQU0sQ0FBQ0QsUUFBUUMsTUFBTSxDQUFDQyxpQkFBaUJYLFNBQVNBO0FBQ3JFO0FBQ0EsU0FBU0wscUJBQXFCSyxLQUFLLFVBQVUsR0FBWCxFQUFlUyxPQUFPLFVBQVUsR0FBWCxFQUFlLFVBQVU7SUFDOUUsT0FBT0EsU0FBUyxJQUFJQyxNQUFNLENBQUNELE9BQU9HLFdBQVcsSUFBSSxLQUFLRixNQUFNLENBQUNWLFFBQVFBO0FBQ3ZFO0FBQ0EsU0FBU1csaUJBQWlCRSxJQUFJLFVBQVUsR0FBWCxFQUFlLFVBQVU7SUFDcEQsSUFBSUMsTUFBTTtJQUNWLElBQUlDLG1CQUFtQjtJQUN2QixJQUFLLElBQUlQLElBQUksR0FBR0EsSUFBSUssSUFBSVgsTUFBTSxFQUFFTSxJQUFLO1FBQ25DLElBQUlPLGtCQUFrQjtZQUNwQkQsT0FBT0QsR0FBRyxDQUFDTCxFQUFFLENBQUNRLFdBQVc7WUFDekJELG1CQUFtQjtRQUNyQixPQUFPLElBQUlGLEdBQUcsQ0FBQ0wsRUFBRSxLQUFLLEtBQUs7WUFDekJPLG1CQUFtQjtRQUNyQixPQUFPO1lBQ0xELE9BQU9ELEdBQUcsQ0FBQ0wsRUFBRTtRQUNmO0lBQ0Y7SUFDQSxPQUFPTTtBQUNUO0FBRUEsaUVBQWlFO0FBQ2pFLGdGQUFnRjtBQUNoRixzRUFBc0U7QUFDdEUsSUFBSUcsV0FBV3pCLGtCQUFlLEdBQUlLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJhc29yX2Nsb25lLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvdXRpbHMvZ2V0UHJlZml4LmpzPzQ0YTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmJyb3dzZXJQcmVmaXhUb0tleSA9IGJyb3dzZXJQcmVmaXhUb0tleTtcbmV4cG9ydHMuYnJvd3NlclByZWZpeFRvU3R5bGUgPSBicm93c2VyUHJlZml4VG9TdHlsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0UHJlZml4ID0gZ2V0UHJlZml4O1xuY29uc3QgcHJlZml4ZXMgPSBbJ01veicsICdXZWJraXQnLCAnTycsICdtcyddO1xuZnVuY3Rpb24gZ2V0UHJlZml4KCkgLyo6IHN0cmluZyove1xuICB2YXIgX3dpbmRvdyRkb2N1bWVudDtcbiAgbGV0IHByb3AgLyo6IHN0cmluZyovID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAndHJhbnNmb3JtJztcbiAgLy8gRW5zdXJlIHdlJ3JlIHJ1bm5pbmcgaW4gYW4gZW52aXJvbm1lbnQgd2hlcmUgdGhlcmUgaXMgYWN0dWFsbHkgYSBnbG9iYWxcbiAgLy8gYHdpbmRvd2Agb2JqXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuICcnO1xuXG4gIC8vIElmIHdlJ3JlIGluIGEgcHNldWRvLWJyb3dzZXIgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQsIHRoaXMgYWNjZXNzXG4gIC8vIHBhdGggbWF5IG5vdCBleGlzdCwgc28gYmFpbCBvdXQgaWYgaXQgZG9lc24ndC5cbiAgY29uc3Qgc3R5bGUgPSAoX3dpbmRvdyRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkgPT09IG51bGwgfHwgX3dpbmRvdyRkb2N1bWVudCA9PT0gdm9pZCAwIHx8IChfd2luZG93JGRvY3VtZW50ID0gX3dpbmRvdyRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpID09PSBudWxsIHx8IF93aW5kb3ckZG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3ckZG9jdW1lbnQuc3R5bGU7XG4gIGlmICghc3R5bGUpIHJldHVybiAnJztcbiAgaWYgKHByb3AgaW4gc3R5bGUpIHJldHVybiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChicm93c2VyUHJlZml4VG9LZXkocHJvcCwgcHJlZml4ZXNbaV0pIGluIHN0eWxlKSByZXR1cm4gcHJlZml4ZXNbaV07XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gYnJvd3NlclByZWZpeFRvS2V5KHByb3AgLyo6IHN0cmluZyovLCBwcmVmaXggLyo6IHN0cmluZyovKSAvKjogc3RyaW5nKi97XG4gIHJldHVybiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdChrZWJhYlRvVGl0bGVDYXNlKHByb3ApKSA6IHByb3A7XG59XG5mdW5jdGlvbiBicm93c2VyUHJlZml4VG9TdHlsZShwcm9wIC8qOiBzdHJpbmcqLywgcHJlZml4IC8qOiBzdHJpbmcqLykgLyo6IHN0cmluZyove1xuICByZXR1cm4gcHJlZml4ID8gXCItXCIuY29uY2F0KHByZWZpeC50b0xvd2VyQ2FzZSgpLCBcIi1cIikuY29uY2F0KHByb3ApIDogcHJvcDtcbn1cbmZ1bmN0aW9uIGtlYmFiVG9UaXRsZUNhc2Uoc3RyIC8qOiBzdHJpbmcqLykgLyo6IHN0cmluZyove1xuICBsZXQgb3V0ID0gJyc7XG4gIGxldCBzaG91bGRDYXBpdGFsaXplID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2hvdWxkQ2FwaXRhbGl6ZSkge1xuICAgICAgb3V0ICs9IHN0cltpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgc2hvdWxkQ2FwaXRhbGl6ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSAnLScpIHtcbiAgICAgIHNob3VsZENhcGl0YWxpemUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gc3RyW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vLyBEZWZhdWx0IGV4cG9ydCBpcyB0aGUgcHJlZml4IGl0c2VsZiwgbGlrZSAnTW96JywgJ1dlYmtpdCcsIGV0Y1xuLy8gTm90ZSB0aGF0IHlvdSBtYXkgaGF2ZSB0byByZS10ZXN0IGZvciBjZXJ0YWluIHRoaW5nczsgZm9yIGluc3RhbmNlLCBDaHJvbWUgNTBcbi8vIGNhbiBoYW5kbGUgdW5wcmVmaXhlZCBgdHJhbnNmb3JtYCwgYnV0IG5vdCB1bnByZWZpeGVkIGB1c2VyLXNlbGVjdGBcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdCA9IChnZXRQcmVmaXgoKSAvKjogc3RyaW5nKi8pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJyb3dzZXJQcmVmaXhUb0tleSIsImJyb3dzZXJQcmVmaXhUb1N0eWxlIiwiZGVmYXVsdCIsImdldFByZWZpeCIsInByZWZpeGVzIiwiX3dpbmRvdyRkb2N1bWVudCIsInByb3AiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJzdHlsZSIsIndpbmRvdyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiaSIsInByZWZpeCIsImNvbmNhdCIsImtlYmFiVG9UaXRsZUNhc2UiLCJ0b0xvd2VyQ2FzZSIsInN0ciIsIm91dCIsInNob3VsZENhcGl0YWxpemUiLCJ0b1VwcGVyQ2FzZSIsIl9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/utils/getPrefix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/utils/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/log.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = log;\n/*eslint no-console:0*/ function log() {\n    if (false) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9sb2cuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUdHO0FBQ2xCLHFCQUFxQixHQUNyQixTQUFTQTtJQUNQLElBQUlDLEtBQVNBLEVBQUVDLEVBQTBCQztBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYXNvcl9jbG9uZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2xvZy5qcz9lMDYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbG9nO1xuLyplc2xpbnQgbm8tY29uc29sZTowKi9cbmZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKHVuZGVmaW5lZCkgY29uc29sZS5sb2coLi4uYXJndW1lbnRzKTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwibG9nIiwidW5kZWZpbmVkIiwiY29uc29sZSIsImFyZ3VtZW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/utils/log.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/utils/positionFns.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/positionFns.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nexports.getBoundPosition = getBoundPosition;\nexports.getControlPosition = getControlPosition;\nexports.snapToGrid = snapToGrid;\nvar _shims = __webpack_require__(/*! ./shims */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _domFns = __webpack_require__(/*! ./domFns */ \"(ssr)/./node_modules/react-draggable/build/cjs/utils/domFns.js\");\n/*:: import type Draggable from '../Draggable';*/ /*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/ /*:: import type DraggableCore from '../DraggableCore';*/ function getBoundPosition(draggable /*: Draggable*/ , x /*: number*/ , y /*: number*/ ) /*: [number, number]*/ {\n    // If no bounds, short-circuit and move on\n    if (!draggable.props.bounds) return [\n        x,\n        y\n    ];\n    // Clone new bounds\n    let { bounds } = draggable.props;\n    bounds = typeof bounds === \"string\" ? bounds : cloneBounds(bounds);\n    const node = findDOMNode(draggable);\n    if (typeof bounds === \"string\") {\n        const { ownerDocument } = node;\n        const ownerWindow = ownerDocument.defaultView;\n        let boundNode;\n        if (bounds === \"parent\") {\n            boundNode = node.parentNode;\n        } else {\n            boundNode = ownerDocument.querySelector(bounds);\n        }\n        if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n            throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n        }\n        const boundNodeEl /*: HTMLElement*/  = boundNode; // for Flow, can't seem to refine correctly\n        const nodeStyle = ownerWindow.getComputedStyle(node);\n        const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);\n        // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n        bounds = {\n            left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n            top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n            right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n            bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n        };\n    }\n    // Keep x and y below right and bottom limits...\n    if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n    if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);\n    // But above left and top limits.\n    if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n    if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n    return [\n        x,\n        y\n    ];\n}\nfunction snapToGrid(grid /*: [number, number]*/ , pendingX /*: number*/ , pendingY /*: number*/ ) /*: [number, number]*/ {\n    const x = Math.round(pendingX / grid[0]) * grid[0];\n    const y = Math.round(pendingY / grid[1]) * grid[1];\n    return [\n        x,\n        y\n    ];\n}\nfunction canDragX(draggable /*: Draggable*/ ) /*: boolean*/ {\n    return draggable.props.axis === \"both\" || draggable.props.axis === \"x\";\n}\nfunction canDragY(draggable /*: Draggable*/ ) /*: boolean*/ {\n    return draggable.props.axis === \"both\" || draggable.props.axis === \"y\";\n}\n// Get {x, y} positions from event.\nfunction getControlPosition(e /*: MouseTouchEvent*/ , touchIdentifier /*: ?number*/ , draggableCore /*: DraggableCore*/ ) /*: ?ControlPosition*/ {\n    const touchObj = typeof touchIdentifier === \"number\" ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n    if (typeof touchIdentifier === \"number\" && !touchObj) return null; // not the right touch\n    const node = findDOMNode(draggableCore);\n    // User can provide an offsetParent if desired.\n    const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n    return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n}\n// Create an data object exposed by <DraggableCore>'s events\nfunction createCoreData(draggable /*: DraggableCore*/ , x /*: number*/ , y /*: number*/ ) /*: DraggableData*/ {\n    const isStart = !(0, _shims.isNum)(draggable.lastX);\n    const node = findDOMNode(draggable);\n    if (isStart) {\n        // If this is our first move, use the x and y as last coords.\n        return {\n            node,\n            deltaX: 0,\n            deltaY: 0,\n            lastX: x,\n            lastY: y,\n            x,\n            y\n        };\n    } else {\n        // Otherwise calculate proper values.\n        return {\n            node,\n            deltaX: x - draggable.lastX,\n            deltaY: y - draggable.lastY,\n            lastX: draggable.lastX,\n            lastY: draggable.lastY,\n            x,\n            y\n        };\n    }\n}\n// Create an data exposed by <Draggable>'s events\nfunction createDraggableData(draggable /*: Draggable*/ , coreData /*: DraggableData*/ ) /*: DraggableData*/ {\n    const scale = draggable.props.scale;\n    return {\n        node: coreData.node,\n        x: draggable.state.x + coreData.deltaX / scale,\n        y: draggable.state.y + coreData.deltaY / scale,\n        deltaX: coreData.deltaX / scale,\n        deltaY: coreData.deltaY / scale,\n        lastX: draggable.state.x,\n        lastY: draggable.state.y\n    };\n}\n// A lot faster than stringify/parse\nfunction cloneBounds(bounds /*: Bounds*/ ) /*: Bounds*/ {\n    return {\n        left: bounds.left,\n        top: bounds.top,\n        right: bounds.right,\n        bottom: bounds.bottom\n    };\n}\nfunction findDOMNode(draggable /*: Draggable | DraggableCore*/ ) /*: HTMLElement*/ {\n    const node = draggable.findDOMNode();\n    if (!node) {\n        throw new Error(\"<DraggableCore>: Unmounted during event!\");\n    }\n    // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n    return node;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9wb3NpdGlvbkZucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsZ0JBQWdCLEdBQUdFO0FBQ25CRixnQkFBZ0IsR0FBR0c7QUFDbkJILHNCQUFzQixHQUFHSTtBQUN6QkosMkJBQTJCLEdBQUdLO0FBQzlCTCx3QkFBd0IsR0FBR007QUFDM0JOLDBCQUEwQixHQUFHTztBQUM3QlAsa0JBQWtCLEdBQUdRO0FBQ3JCLElBQUlDLFNBQVNDLG1CQUFPQSxDQUFDLDhFQUFTO0FBQzlCLElBQUlDLFVBQVVELG1CQUFPQSxDQUFDLGdGQUFVO0FBQ2hDLCtDQUErQyxHQUMvQywwRkFBMEYsR0FDMUYsdURBQXVELEdBQ3ZELFNBQVNKLGlCQUFpQk0sVUFBVSxhQUFhLEdBQWQsRUFBa0JDLEVBQUUsVUFBVSxHQUFYLEVBQWVDLEVBQUUsVUFBVSxHQUFYLEVBQWUsb0JBQW9CO0lBQ3ZHLDBDQUEwQztJQUMxQyxJQUFJLENBQUNGLFVBQVVHLEtBQUssQ0FBQ0MsTUFBTSxFQUFFLE9BQU87UUFBQ0g7UUFBR0M7S0FBRTtJQUUxQyxtQkFBbUI7SUFDbkIsSUFBSSxFQUNGRSxNQUFNLEVBQ1AsR0FBR0osVUFBVUcsS0FBSztJQUNuQkMsU0FBUyxPQUFPQSxXQUFXLFdBQVdBLFNBQVNDLFlBQVlEO0lBQzNELE1BQU1FLE9BQU9DLFlBQVlQO0lBQ3pCLElBQUksT0FBT0ksV0FBVyxVQUFVO1FBQzlCLE1BQU0sRUFDSkksYUFBYSxFQUNkLEdBQUdGO1FBQ0osTUFBTUcsY0FBY0QsY0FBY0UsV0FBVztRQUM3QyxJQUFJQztRQUNKLElBQUlQLFdBQVcsVUFBVTtZQUN2Qk8sWUFBWUwsS0FBS00sVUFBVTtRQUM3QixPQUFPO1lBQ0xELFlBQVlILGNBQWNLLGFBQWEsQ0FBQ1Q7UUFDMUM7UUFDQSxJQUFJLENBQUVPLENBQUFB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azovL2VyYXNvcl9jbG9uZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL3Bvc2l0aW9uRm5zLmpzP2E5ZDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNhbkRyYWdYID0gY2FuRHJhZ1g7XG5leHBvcnRzLmNhbkRyYWdZID0gY2FuRHJhZ1k7XG5leHBvcnRzLmNyZWF0ZUNvcmVEYXRhID0gY3JlYXRlQ29yZURhdGE7XG5leHBvcnRzLmNyZWF0ZURyYWdnYWJsZURhdGEgPSBjcmVhdGVEcmFnZ2FibGVEYXRhO1xuZXhwb3J0cy5nZXRCb3VuZFBvc2l0aW9uID0gZ2V0Qm91bmRQb3NpdGlvbjtcbmV4cG9ydHMuZ2V0Q29udHJvbFBvc2l0aW9uID0gZ2V0Q29udHJvbFBvc2l0aW9uO1xuZXhwb3J0cy5zbmFwVG9HcmlkID0gc25hcFRvR3JpZDtcbnZhciBfc2hpbXMgPSByZXF1aXJlKFwiLi9zaGltc1wiKTtcbnZhciBfZG9tRm5zID0gcmVxdWlyZShcIi4vZG9tRm5zXCIpO1xuLyo6OiBpbXBvcnQgdHlwZSBEcmFnZ2FibGUgZnJvbSAnLi4vRHJhZ2dhYmxlJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7Qm91bmRzLCBDb250cm9sUG9zaXRpb24sIERyYWdnYWJsZURhdGEsIE1vdXNlVG91Y2hFdmVudH0gZnJvbSAnLi90eXBlcyc7Ki9cbi8qOjogaW1wb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZSBmcm9tICcuLi9EcmFnZ2FibGVDb3JlJzsqL1xuZnVuY3Rpb24gZ2V0Qm91bmRQb3NpdGlvbihkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8pIC8qOiBbbnVtYmVyLCBudW1iZXJdKi97XG4gIC8vIElmIG5vIGJvdW5kcywgc2hvcnQtY2lyY3VpdCBhbmQgbW92ZSBvblxuICBpZiAoIWRyYWdnYWJsZS5wcm9wcy5ib3VuZHMpIHJldHVybiBbeCwgeV07XG5cbiAgLy8gQ2xvbmUgbmV3IGJvdW5kc1xuICBsZXQge1xuICAgIGJvdW5kc1xuICB9ID0gZHJhZ2dhYmxlLnByb3BzO1xuICBib3VuZHMgPSB0eXBlb2YgYm91bmRzID09PSAnc3RyaW5nJyA/IGJvdW5kcyA6IGNsb25lQm91bmRzKGJvdW5kcyk7XG4gIGNvbnN0IG5vZGUgPSBmaW5kRE9NTm9kZShkcmFnZ2FibGUpO1xuICBpZiAodHlwZW9mIGJvdW5kcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lckRvY3VtZW50XG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3Qgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIGxldCBib3VuZE5vZGU7XG4gICAgaWYgKGJvdW5kcyA9PT0gJ3BhcmVudCcpIHtcbiAgICAgIGJvdW5kTm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmROb2RlID0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGJvdW5kcyk7XG4gICAgfVxuICAgIGlmICghKGJvdW5kTm9kZSBpbnN0YW5jZW9mIG93bmVyV2luZG93LkhUTUxFbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgc2VsZWN0b3IgXCInICsgYm91bmRzICsgJ1wiIGNvdWxkIG5vdCBmaW5kIGFuIGVsZW1lbnQuJyk7XG4gICAgfVxuICAgIGNvbnN0IGJvdW5kTm9kZUVsIC8qOiBIVE1MRWxlbWVudCovID0gYm91bmROb2RlOyAvLyBmb3IgRmxvdywgY2FuJ3Qgc2VlbSB0byByZWZpbmUgY29ycmVjdGx5XG4gICAgY29uc3Qgbm9kZVN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCBib3VuZE5vZGVTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUoYm91bmROb2RlRWwpO1xuICAgIC8vIENvbXB1dGUgYm91bmRzLiBUaGlzIGlzIGEgcGFpbiB3aXRoIHBhZGRpbmcgYW5kIG9mZnNldHMgYnV0IHRoaXMgZ2V0cyBpdCBleGFjdGx5IHJpZ2h0LlxuICAgIGJvdW5kcyA9IHtcbiAgICAgIGxlZnQ6IC1ub2RlLm9mZnNldExlZnQgKyAoMCwgX3NoaW1zLmludCkoYm91bmROb2RlU3R5bGUucGFkZGluZ0xlZnQpICsgKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5tYXJnaW5MZWZ0KSxcbiAgICAgIHRvcDogLW5vZGUub2Zmc2V0VG9wICsgKDAsIF9zaGltcy5pbnQpKGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdUb3ApICsgKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5tYXJnaW5Ub3ApLFxuICAgICAgcmlnaHQ6ICgwLCBfZG9tRm5zLmlubmVyV2lkdGgpKGJvdW5kTm9kZUVsKSAtICgwLCBfZG9tRm5zLm91dGVyV2lkdGgpKG5vZGUpIC0gbm9kZS5vZmZzZXRMZWZ0ICsgKDAsIF9zaGltcy5pbnQpKGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdSaWdodCkgLSAoMCwgX3NoaW1zLmludCkobm9kZVN0eWxlLm1hcmdpblJpZ2h0KSxcbiAgICAgIGJvdHRvbTogKDAsIF9kb21GbnMuaW5uZXJIZWlnaHQpKGJvdW5kTm9kZUVsKSAtICgwLCBfZG9tRm5zLm91dGVySGVpZ2h0KShub2RlKSAtIG5vZGUub2Zmc2V0VG9wICsgKDAsIF9zaGltcy5pbnQpKGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdCb3R0b20pIC0gKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5tYXJnaW5Cb3R0b20pXG4gICAgfTtcbiAgfVxuXG4gIC8vIEtlZXAgeCBhbmQgeSBiZWxvdyByaWdodCBhbmQgYm90dG9tIGxpbWl0cy4uLlxuICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLnJpZ2h0KSkgeCA9IE1hdGgubWluKHgsIGJvdW5kcy5yaWdodCk7XG4gIGlmICgoMCwgX3NoaW1zLmlzTnVtKShib3VuZHMuYm90dG9tKSkgeSA9IE1hdGgubWluKHksIGJvdW5kcy5ib3R0b20pO1xuXG4gIC8vIEJ1dCBhYm92ZSBsZWZ0IGFuZCB0b3AgbGltaXRzLlxuICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLmxlZnQpKSB4ID0gTWF0aC5tYXgoeCwgYm91bmRzLmxlZnQpO1xuICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLnRvcCkpIHkgPSBNYXRoLm1heCh5LCBib3VuZHMudG9wKTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cbmZ1bmN0aW9uIHNuYXBUb0dyaWQoZ3JpZCAvKjogW251bWJlciwgbnVtYmVyXSovLCBwZW5kaW5nWCAvKjogbnVtYmVyKi8sIHBlbmRpbmdZIC8qOiBudW1iZXIqLykgLyo6IFtudW1iZXIsIG51bWJlcl0qL3tcbiAgY29uc3QgeCA9IE1hdGgucm91bmQocGVuZGluZ1ggLyBncmlkWzBdKSAqIGdyaWRbMF07XG4gIGNvbnN0IHkgPSBNYXRoLnJvdW5kKHBlbmRpbmdZIC8gZ3JpZFsxXSkgKiBncmlkWzFdO1xuICByZXR1cm4gW3gsIHldO1xufVxuZnVuY3Rpb24gY2FuRHJhZ1goZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUqLykgLyo6IGJvb2xlYW4qL3tcbiAgcmV0dXJuIGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAnYm90aCcgfHwgZHJhZ2dhYmxlLnByb3BzLmF4aXMgPT09ICd4Jztcbn1cbmZ1bmN0aW9uIGNhbkRyYWdZKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8pIC8qOiBib29sZWFuKi97XG4gIHJldHVybiBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAneSc7XG59XG5cbi8vIEdldCB7eCwgeX0gcG9zaXRpb25zIGZyb20gZXZlbnQuXG5mdW5jdGlvbiBnZXRDb250cm9sUG9zaXRpb24oZSAvKjogTW91c2VUb3VjaEV2ZW50Ki8sIHRvdWNoSWRlbnRpZmllciAvKjogP251bWJlciovLCBkcmFnZ2FibGVDb3JlIC8qOiBEcmFnZ2FibGVDb3JlKi8pIC8qOiA/Q29udHJvbFBvc2l0aW9uKi97XG4gIGNvbnN0IHRvdWNoT2JqID0gdHlwZW9mIHRvdWNoSWRlbnRpZmllciA9PT0gJ251bWJlcicgPyAoMCwgX2RvbUZucy5nZXRUb3VjaCkoZSwgdG91Y2hJZGVudGlmaWVyKSA6IG51bGw7XG4gIGlmICh0eXBlb2YgdG91Y2hJZGVudGlmaWVyID09PSAnbnVtYmVyJyAmJiAhdG91Y2hPYmopIHJldHVybiBudWxsOyAvLyBub3QgdGhlIHJpZ2h0IHRvdWNoXG4gIGNvbnN0IG5vZGUgPSBmaW5kRE9NTm9kZShkcmFnZ2FibGVDb3JlKTtcbiAgLy8gVXNlciBjYW4gcHJvdmlkZSBhbiBvZmZzZXRQYXJlbnQgaWYgZGVzaXJlZC5cbiAgY29uc3Qgb2Zmc2V0UGFyZW50ID0gZHJhZ2dhYmxlQ29yZS5wcm9wcy5vZmZzZXRQYXJlbnQgfHwgbm9kZS5vZmZzZXRQYXJlbnQgfHwgbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIHJldHVybiAoMCwgX2RvbUZucy5vZmZzZXRYWUZyb21QYXJlbnQpKHRvdWNoT2JqIHx8IGUsIG9mZnNldFBhcmVudCwgZHJhZ2dhYmxlQ29yZS5wcm9wcy5zY2FsZSk7XG59XG5cbi8vIENyZWF0ZSBhbiBkYXRhIG9iamVjdCBleHBvc2VkIGJ5IDxEcmFnZ2FibGVDb3JlPidzIGV2ZW50c1xuZnVuY3Rpb24gY3JlYXRlQ29yZURhdGEoZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGVDb3JlKi8sIHggLyo6IG51bWJlciovLCB5IC8qOiBudW1iZXIqLykgLyo6IERyYWdnYWJsZURhdGEqL3tcbiAgY29uc3QgaXNTdGFydCA9ICEoMCwgX3NoaW1zLmlzTnVtKShkcmFnZ2FibGUubGFzdFgpO1xuICBjb25zdCBub2RlID0gZmluZERPTU5vZGUoZHJhZ2dhYmxlKTtcbiAgaWYgKGlzU3RhcnQpIHtcbiAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBtb3ZlLCB1c2UgdGhlIHggYW5kIHkgYXMgbGFzdCBjb29yZHMuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGUsXG4gICAgICBkZWx0YVg6IDAsXG4gICAgICBkZWx0YVk6IDAsXG4gICAgICBsYXN0WDogeCxcbiAgICAgIGxhc3RZOiB5LFxuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgcHJvcGVyIHZhbHVlcy5cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZSxcbiAgICAgIGRlbHRhWDogeCAtIGRyYWdnYWJsZS5sYXN0WCxcbiAgICAgIGRlbHRhWTogeSAtIGRyYWdnYWJsZS5sYXN0WSxcbiAgICAgIGxhc3RYOiBkcmFnZ2FibGUubGFzdFgsXG4gICAgICBsYXN0WTogZHJhZ2dhYmxlLmxhc3RZLFxuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59XG5cbi8vIENyZWF0ZSBhbiBkYXRhIGV4cG9zZWQgYnkgPERyYWdnYWJsZT4ncyBldmVudHNcbmZ1bmN0aW9uIGNyZWF0ZURyYWdnYWJsZURhdGEoZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUqLywgY29yZURhdGEgLyo6IERyYWdnYWJsZURhdGEqLykgLyo6IERyYWdnYWJsZURhdGEqL3tcbiAgY29uc3Qgc2NhbGUgPSBkcmFnZ2FibGUucHJvcHMuc2NhbGU7XG4gIHJldHVybiB7XG4gICAgbm9kZTogY29yZURhdGEubm9kZSxcbiAgICB4OiBkcmFnZ2FibGUuc3RhdGUueCArIGNvcmVEYXRhLmRlbHRhWCAvIHNjYWxlLFxuICAgIHk6IGRyYWdnYWJsZS5zdGF0ZS55ICsgY29yZURhdGEuZGVsdGFZIC8gc2NhbGUsXG4gICAgZGVsdGFYOiBjb3JlRGF0YS5kZWx0YVggLyBzY2FsZSxcbiAgICBkZWx0YVk6IGNvcmVEYXRhLmRlbHRhWSAvIHNjYWxlLFxuICAgIGxhc3RYOiBkcmFnZ2FibGUuc3RhdGUueCxcbiAgICBsYXN0WTogZHJhZ2dhYmxlLnN0YXRlLnlcbiAgfTtcbn1cblxuLy8gQSBsb3QgZmFzdGVyIHRoYW4gc3RyaW5naWZ5L3BhcnNlXG5mdW5jdGlvbiBjbG9uZUJvdW5kcyhib3VuZHMgLyo6IEJvdW5kcyovKSAvKjogQm91bmRzKi97XG4gIHJldHVybiB7XG4gICAgbGVmdDogYm91bmRzLmxlZnQsXG4gICAgdG9wOiBib3VuZHMudG9wLFxuICAgIHJpZ2h0OiBib3VuZHMucmlnaHQsXG4gICAgYm90dG9tOiBib3VuZHMuYm90dG9tXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kRE9NTm9kZShkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSB8IERyYWdnYWJsZUNvcmUqLykgLyo6IEhUTUxFbGVtZW50Ki97XG4gIGNvbnN0IG5vZGUgPSBkcmFnZ2FibGUuZmluZERPTU5vZGUoKTtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc8RHJhZ2dhYmxlQ29yZT46IFVubW91bnRlZCBkdXJpbmcgZXZlbnQhJyk7XG4gIH1cbiAgLy8gJEZsb3dJZ25vcmUgd2UgY2FuJ3QgYXNzZXJ0IG9uIEhUTUxFbGVtZW50IGR1ZSB0byB0ZXN0cy4uLiBGSVhNRVxuICByZXR1cm4gbm9kZTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjYW5EcmFnWCIsImNhbkRyYWdZIiwiY3JlYXRlQ29yZURhdGEiLCJjcmVhdGVEcmFnZ2FibGVEYXRhIiwiZ2V0Qm91bmRQb3NpdGlvbiIsImdldENvbnRyb2xQb3NpdGlvbiIsInNuYXBUb0dyaWQiLCJfc2hpbXMiLCJyZXF1aXJlIiwiX2RvbUZucyIsImRyYWdnYWJsZSIsIngiLCJ5IiwicHJvcHMiLCJib3VuZHMiLCJjbG9uZUJvdW5kcyIsIm5vZGUiLCJmaW5kRE9NTm9kZSIsIm93bmVyRG9jdW1lbnQiLCJvd25lcldpbmRvdyIsImRlZmF1bHRWaWV3IiwiYm91bmROb2RlIiwicGFyZW50Tm9kZSIsInF1ZXJ5U2VsZWN0b3IiLCJIVE1MRWxlbWVudCIsIkVycm9yIiwiYm91bmROb2RlRWwiLCJub2RlU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiYm91bmROb2RlU3R5bGUiLCJsZWZ0Iiwib2Zmc2V0TGVmdCIsImludCIsInBhZGRpbmdMZWZ0IiwibWFyZ2luTGVmdCIsInRvcCIsIm9mZnNldFRvcCIsInBhZGRpbmdUb3AiLCJtYXJnaW5Ub3AiLCJyaWdodCIsImlubmVyV2lkdGgiLCJvdXRlcldpZHRoIiwicGFkZGluZ1JpZ2h0IiwibWFyZ2luUmlnaHQiLCJib3R0b20iLCJpbm5lckhlaWdodCIsIm91dGVySGVpZ2h0IiwicGFkZGluZ0JvdHRvbSIsIm1hcmdpbkJvdHRvbSIsImlzTnVtIiwiTWF0aCIsIm1pbiIsIm1heCIsImdyaWQiLCJwZW5kaW5nWCIsInBlbmRpbmdZIiwicm91bmQiLCJheGlzIiwiZSIsInRvdWNoSWRlbnRpZmllciIsImRyYWdnYWJsZUNvcmUiLCJ0b3VjaE9iaiIsImdldFRvdWNoIiwib2Zmc2V0UGFyZW50IiwiYm9keSIsIm9mZnNldFhZRnJvbVBhcmVudCIsInNjYWxlIiwiaXNTdGFydCIsImxhc3RYIiwiZGVsdGFYIiwiZGVsdGFZIiwibGFzdFkiLCJjb3JlRGF0YSIsInN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/utils/positionFns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-draggable/build/cjs/utils/shims.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.dontSetMe = dontSetMe;\nexports.findInArray = findInArray;\nexports.int = int;\nexports.isFunction = isFunction;\nexports.isNum = isNum;\n// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\nfunction findInArray(array /*: Array<any> | TouchList*/ , callback /*: Function*/ ) /*: any*/ {\n    for(let i = 0, length = array.length; i < length; i++){\n        if (callback.apply(callback, [\n            array[i],\n            i,\n            array\n        ])) return array[i];\n    }\n}\nfunction isFunction(func /*: any*/ ) /*: boolean %checks*/ {\n    // $FlowIgnore[method-unbinding]\n    return typeof func === \"function\" || Object.prototype.toString.call(func) === \"[object Function]\";\n}\nfunction isNum(num /*: any*/ ) /*: boolean %checks*/ {\n    return typeof num === \"number\" && !isNaN(num);\n}\nfunction int(a /*: string*/ ) /*: number*/ {\n    return parseInt(a, 10);\n}\nfunction dontSetMe(props /*: Object*/ , propName /*: string*/ , componentName /*: string*/ ) /*: ?Error*/ {\n    if (props[propName]) {\n        return new Error(\"Invalid prop \".concat(propName, \" passed to \").concat(componentName, \" - do not set this, set it on the child.\"));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9zaGltcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUdFO0FBQ3BCRixtQkFBbUIsR0FBR0c7QUFDdEJILFdBQVcsR0FBR0k7QUFDZEosa0JBQWtCLEdBQUdLO0FBQ3JCTCxhQUFhLEdBQUdNO0FBQ2hCLHFFQUFxRTtBQUNyRSxTQUFTSCxZQUFZSSxNQUFNLDBCQUEwQixHQUEzQixFQUErQkMsU0FBUyxZQUFZLEdBQWIsRUFBaUIsT0FBTztJQUN2RixJQUFLLElBQUlDLElBQUksR0FBR0MsU0FBU0gsTUFBTUcsTUFBTSxFQUFFRCxJQUFJQyxRQUFRRCxJQUFLO1FBQ3RELElBQUlELFNBQVNHLEtBQUssQ0FBQ0gsVUFBVTtZQUFDRCxLQUFLLENBQUNFLEVBQUU7WUFBRUE7WUFBR0Y7U0FBTSxHQUFHLE9BQU9BLEtBQUssQ0FBQ0UsRUFBRTtJQUNyRTtBQUNGO0FBQ0EsU0FBU0osV0FBV08sS0FBSyxPQUFPLEdBQVIsRUFBWSxtQkFBbUI7SUFDckQsZ0NBQWdDO0lBQ2hDLE9BQU8sT0FBT0EsU0FBUyxjQUFjZCxPQUFPZSxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDSCxVQUFVO0FBQ2hGO0FBQ0EsU0FBU04sTUFBTVUsSUFBSSxPQUFPLEdBQVIsRUFBWSxtQkFBbUI7SUFDL0MsT0FBTyxPQUFPQSxRQUFRLFlBQVksQ0FBQ0MsTUFBTUQ7QUFDM0M7QUFDQSxTQUFTWixJQUFJYyxFQUFFLFVBQVUsR0FBWCxFQUFlLFVBQVU7SUFDckMsT0FBT0MsU0FBU0QsR0FBRztBQUNyQjtBQUNBLFNBQVNoQixVQUFVa0IsTUFBTSxVQUFVLEdBQVgsRUFBZUMsU0FBUyxVQUFVLEdBQVgsRUFBZUMsY0FBYyxVQUFVLEdBQVgsRUFBZSxVQUFVO0lBQ2xHLElBQUlGLEtBQUssQ0FBQ0MsU0FBUyxFQUFFO1FBQ25CLE9BQU8sSUFBSUUsTUFBTSxnQkFBZ0JDLE1BQU0sQ0FBQ0gsVUFBVSxlQUFlRyxNQUFNLENBQUNGLGVBQWU7SUFDekY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2VyYXNvcl9jbG9uZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL3NoaW1zLmpzP2Q5ZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRvbnRTZXRNZSA9IGRvbnRTZXRNZTtcbmV4cG9ydHMuZmluZEluQXJyYXkgPSBmaW5kSW5BcnJheTtcbmV4cG9ydHMuaW50ID0gaW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNOdW0gPSBpc051bTtcbi8vIEBjcmVkaXRzIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3JvZ296aG5pa29mZi9hNDNjZmVkMjdjNDFlNGU2OGNkY1xuZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXkgLyo6IEFycmF5PGFueT4gfCBUb3VjaExpc3QqLywgY2FsbGJhY2sgLyo6IEZ1bmN0aW9uKi8pIC8qOiBhbnkqL3tcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBbYXJyYXlbaV0sIGksIGFycmF5XSkpIHJldHVybiBhcnJheVtpXTtcbiAgfVxufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jIC8qOiBhbnkqLykgLyo6IGJvb2xlYW4gJWNoZWNrcyove1xuICAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZ1bmMpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuZnVuY3Rpb24gaXNOdW0obnVtIC8qOiBhbnkqLykgLyo6IGJvb2xlYW4gJWNoZWNrcyove1xuICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG51bSk7XG59XG5mdW5jdGlvbiBpbnQoYSAvKjogc3RyaW5nKi8pIC8qOiBudW1iZXIqL3tcbiAgcmV0dXJuIHBhcnNlSW50KGEsIDEwKTtcbn1cbmZ1bmN0aW9uIGRvbnRTZXRNZShwcm9wcyAvKjogT2JqZWN0Ki8sIHByb3BOYW1lIC8qOiBzdHJpbmcqLywgY29tcG9uZW50TmFtZSAvKjogc3RyaW5nKi8pIC8qOiA/RXJyb3IqL3tcbiAgaWYgKHByb3BzW3Byb3BOYW1lXSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3AgXCIuY29uY2F0KHByb3BOYW1lLCBcIiBwYXNzZWQgdG8gXCIpLmNvbmNhdChjb21wb25lbnROYW1lLCBcIiAtIGRvIG5vdCBzZXQgdGhpcywgc2V0IGl0IG9uIHRoZSBjaGlsZC5cIikpO1xuICB9XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZG9udFNldE1lIiwiZmluZEluQXJyYXkiLCJpbnQiLCJpc0Z1bmN0aW9uIiwiaXNOdW0iLCJhcnJheSIsImNhbGxiYWNrIiwiaSIsImxlbmd0aCIsImFwcGx5IiwiZnVuYyIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIm51bSIsImlzTmFOIiwiYSIsInBhcnNlSW50IiwicHJvcHMiLCJwcm9wTmFtZSIsImNvbXBvbmVudE5hbWUiLCJFcnJvciIsImNvbmNhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/build/cjs/utils/shims.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: () => (/* binding */ clsx),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction r(e) {\n    var t, f, n = \"\";\n    if (\"string\" == typeof e || \"number\" == typeof e) n += e;\n    else if (\"object\" == typeof e) if (Array.isArray(e)) for(t = 0; t < e.length; t++)e[t] && (f = r(e[t])) && (n && (n += \" \"), n += f);\n    else for(t in e)e[t] && (n && (n += \" \"), n += t);\n    return n;\n}\nfunction clsx() {\n    for(var e, t, f = 0, n = \"\"; f < arguments.length;)(e = arguments[f++]) && (t = r(e)) && (n && (n += \" \"), n += t);\n    return n;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clsx);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsU0FBU0EsRUFBRUMsQ0FBQztJQUFFLElBQUlDLEdBQUVDLEdBQUVDLElBQUU7SUFBRyxJQUFHLFlBQVUsT0FBT0gsS0FBRyxZQUFVLE9BQU9BLEdBQUVHLEtBQUdIO1NBQU8sSUFBRyxZQUFVLE9BQU9BLEdBQUUsSUFBR0ksTUFBTUMsT0FBTyxDQUFDTCxJQUFHLElBQUlDLElBQUUsR0FBRUEsSUFBRUQsRUFBRU0sTUFBTSxFQUFDTCxJQUFJRCxDQUFDLENBQUNDLEVBQUUsSUFBR0MsQ0FBQUEsSUFBRUgsRUFBRUMsQ0FBQyxDQUFDQyxFQUFFLE1BQUtFLENBQUFBLEtBQUlBLENBQUFBLEtBQUcsR0FBRSxHQUFHQSxLQUFHRCxDQUFBQTtTQUFRLElBQUlELEtBQUtELEVBQUVBLENBQUMsQ0FBQ0MsRUFBRSxJQUFHRSxDQUFBQSxLQUFJQSxDQUFBQSxLQUFHLEdBQUUsR0FBR0EsS0FBR0YsQ0FBQUE7SUFBRyxPQUFPRTtBQUFDO0FBQVEsU0FBU0k7SUFBTyxJQUFJLElBQUlQLEdBQUVDLEdBQUVDLElBQUUsR0FBRUMsSUFBRSxJQUFHRCxJQUFFTSxVQUFVRixNQUFNLEVBQUUsQ0FBQ04sSUFBRVEsU0FBUyxDQUFDTixJQUFJLEtBQUlELENBQUFBLElBQUVGLEVBQUVDLEVBQUMsS0FBS0csQ0FBQUEsS0FBSUEsQ0FBQUEsS0FBRyxHQUFFLEdBQUdBLEtBQUdGLENBQUFBO0lBQUcsT0FBT0U7QUFBQztBQUFDLGlFQUFlSSxJQUFJQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJhc29yX2Nsb25lLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcz81NGQ3Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKWZvcih0PTA7dDxlLmxlbmd0aDt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpO2Vsc2UgZm9yKHQgaW4gZSllW3RdJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCI7Zjxhcmd1bWVudHMubGVuZ3RoOykoZT1hcmd1bWVudHNbZisrXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyJdLCJuYW1lcyI6WyJyIiwiZSIsInQiLCJmIiwibiIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImNsc3giLCJhcmd1bWVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js\n");

/***/ })

};
;